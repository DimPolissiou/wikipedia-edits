{"title_page": "Aphanotus", "text_new": "{{italic title}}\n{{Taxobox\n| name = ''Aphanotus''\n| regnum = [[Animalia]]\n| phylum = [[Arthropoda]]\n| classis = [[Insecta]]\n| ordo = [[Coleoptera]]\n| familia = [[Tenebrionidae]]\n| subfamilia = [[Tenebrioninae]]\n| tribus = [[Triboliini]]\n| genus = '''''Aphanotus'''''\n| genus_authority = Leconte, 1962<ref>{{cite journal | last1= LeConte | first1=JL | year=1962 | title= Classification of the Coleoptera of North America prepared for the Smithsonian Institution | journal= Washington: Smithsonian Institution | volume= 233| url=https://www.biodiversitylibrary.org/item/85732#page/268/mode/1up\n| pages=209\u2013286 (''Aphanotus'': p. 233)}}</ref>\n}}\n'''''Aphanotus''''' is a genus of darkling beetles in the family [[Tenebrionidae]]. Species in this genus were previously within ''Tribolium'' but placed in the genus ''Aphanotus'' following phylogenetic evidence.<ref>{{cite journal | last1=  Angelini| first1= DR| last2= Jockusch| first2= EL| year= 2008| title= Relationships among pest flour beetles of the genus ''Tribolium'' (Tenebrionidae) inferred from multiple molecular markers| journal= Molecular Phylogenetics and Evolution| volume= 46| issue= 1| pages= 127\u2013141}}</ref>\n\n==Species==\n* ''[[North American flour beetle|Aphanotus brevicornis]]''  (Leconte, 1859)\n* ''[[Aphanotus carinatum]]'' (Hinton, 1948)\n* ''[[Aphanotus gebieni]]'' (Uyttenboogaart, 1934)\n* ''[[Aphanotus parallelus]]'' (Casey, 1890)\n* ''[[Aphanotus linsleyi]]'' (Hinton, 1948)\n* ''[[Aphanotus setosum]]'' (Triplehorn, 1978)\n* ''[[Aphanotus uezumii]]'' (Nakane, 1963)\n\n==References==\n{{reflist}}\n\n\n\n[[Category:Tenebrionidae genera]]\n", "text_old": "{{italic title}}\n{{Taxobox\n| name = ''Aphanotus''\n| regnum = [[Animalia]]\n| phylum = [[Arthropoda]]\n| classis = [[Insecta]]\n| ordo = [[Coleoptera]]\n| familia = [[Tenebrionidae]]\n| subfamilia = [[Tenebrioninae]]\n| tribus = [[Triboliini]]\n| genus = '''''Aphanotus'''''\n| genus_authority = Leconte, 1962<ref>{{cite journal | last1= LeConte | first1=JL | year=1962 | title= Classification of the Coleoptera of North America prepared for the Smithsonian Institution | journal= Washington: Smithsonian Institution | volume= 233| url=https://www.biodiversitylibrary.org/item/85732#page/268/mode/1up\n| pages=209\u2013286 (''Aphanotus'': p. 233)}}</ref>\n}}\n'''''Aphanotus''''' is a genus of darkling beetles in the family [[Tenebrionidae]]. Species in this genus were previously within ''Tribolium'' but placed in the genus ''Aphanotus'' following phylogenetic evidence.<ref>{{cite journal | last1=  Angelini| first1= DR| last2= Jockusch| first2= EL| year= 2008| title= Relationships among pest flour beetles of the genus ''Tribolium'' (Tenebrionidae) inferred from multiple molecular markers| journal= Molecular Phylogenetics and Evolution| volume= 46| issue= 1| pages= 127\u2013141}}</ref>\n\n==Species==\n* ''[[North American flour beetle|Aphanotus brevicornis]]''  (Leconte, 1859)\n* ''[[Aphanotus carinatum]]'' (Hinton, 1948)\n* ''[[Aphanotus gebieni ]]'' (Uyttenboogaart, 1934)\n* ''[[Aphanotus parallelus ]]'' (Casey, 1890)\n* ''[[Aphanotus linsleyi]]'' (Hinton, 1948)\n* ''[[Aphanotus setosum]]'' (Triplehorn, 1978)\n* ''[[Aphanotus uezumii ]]'' (Nakane, 1963)\n\n==References==\n{{reflist}}\n\n\n\n[[Category:Tenebrionidae genera]]\n", "name_user": "Entomologger", "label": "safe", "comment": "Coor. typos", "url_page": "//en.wikipedia.org/wiki/Aphanotus"}
{"title_page": "Dependency injection", "text_new": "{{Refimprove|date=July 2019}}\nIn [[software engineering]], '''dependency injection''' is a technique whereby one [[Object (computer science)|object]] supplies the dependencies of another object. A \"dependency\" is an object that can be used, for example as a [[Service (systems architecture)|service]]. Instead of a client specifying which service it will use, something tells the client what service to use. The \"injection\" refers to the passing of a dependency (a service) into the object (a [[Client (computing)|client]]) that would use it. The service is made part of the client's [[State (computer science)|state]].<ref name=\"JamesShore\">{{Cite web|title = James Shore: Dependency Injection Demystified|url = http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html|website = www.jamesshore.com|accessdate = 2015-07-18|first = Titanium|last = I.T.}}</ref> Passing the service to the client, rather than allowing a client to build or [[Service locator pattern|find the service]], is the fundamental requirement of the pattern.\n\nThe intent behind dependency injection is to achieve [[Separation of Concerns]] of construction and use of objects. This can increase readability and code reuse.\n\nDependency injection is one form of the broader technique of [[inversion of control]]. A client who wants to call some services should not have to know how to construct those services. Instead, the client delegates the responsibility of providing its services to external code (the injector). The client is not allowed to call the injector code;<ref name=\"HollywoodPrinciple.c2\">{{Cite web|title = HollywoodPrinciple|url = http://c2.com/cgi/wiki?HollywoodPrinciple|website = c2.com|accessdate = 2015-07-19}}</ref> it is the injector that constructs the services. The injector then injects (passes) the services into the client which might already exist or may also be constructed by the injector. The client then uses the services. This means the client does not need to know about the injector, how to construct the services, or even which actual services it is using. The client only needs to know about the intrinsic interfaces of the services because these define how the client may use the services. This separates the responsibility of \"use\" from the responsibility of \"construction\".\n\n==Intent==\n\nDependency Injection solves problems such as:<ref>{{cite web|title=The Dependency Injection design pattern - Problem, Solution, and Applicability|url=http://w3sdesign.com/?gr=u01&ugr=proble|website=w3sDesign.com|accessdate=2017-08-12}}</ref>\n\n* How can an application or [[Class (computer programming)|class]] be independent of how its objects are created?\n* How can the way objects are created be specified in separate configuration files?\n* How can an application support different configurations?\n\nCreating objects directly within the class that requires the objects is inflexible because it commits the class to particular objects and makes it impossible to change the instantiation later independently from (without having to change) the class. It stops the class from being reusable if other objects are required, and it makes the class hard to test because real objects can not be replaced with mock objects.\n\nA class is no longer responsible for creating the objects it requires, and it does not have to delegate instantiation to a factory object as in the [[Abstract_factory_pattern|Abstract Factory]]<ref name=\"GoF\">{{cite book|author=Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides|title=Design Patterns: Elements of Reusable Object-Oriented Software|year=1994|publisher=Addison Wesley|isbn=0-201-63361-2|pages=[https://archive.org/details/designpatternsel00gamm/page/87 87ff]|url-access=registration|url=https://archive.org/details/designpatternsel00gamm/page/87}}</ref> design pattern.<br>See also the UML class and sequence diagram below.\n\n==Overview==\n{{Quote box\n| quote = '''Dependency injection for five-year-olds'''\n\nWhen you go and get things out of the refrigerator for yourself, you can cause problems. You might leave the door open, you might get something Mommy or Daddy doesn't want you to have. You might even be looking for something we don't even have or which has expired.\n\nWhat you should be doing is stating a need, \"I need something to drink with lunch,\" and then we will make sure you have something when you sit down to eat.\n|source=John Munsch, 28 October 2009.<ref name=MarkSeeman2011P4>{{cite book|last1=Seeman|first1=Mark|title=Dependency Injection in .NET|date=October 2011|publisher=Manning Publications|isbn=9781935182504|page=4}}<!--|accessdate=18 July 2015--></ref><ref>{{Cite web|title = Dependency Injection in NET|url = http://philkildea.co.uk/james/books/Dependency.Injection.in.NET.pdf|page=4|website = philkildea.co.uk|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = How to explain dependency injection to a 5-year-old?|url = https://stackoverflow.com/questions/1638919/how-to-explain-dependency-injection-to-a-5-year-old|website = stackoverflow.com|accessdate = 2015-07-18}}</ref>\n| align = right\n| width = 33%\n}}\n\nDependency injection separates the creation of a client's dependencies from the client's behavior, which allows program designs to be [[Loose coupling|loosely]] [[Coupling (computer programming)|coupled]]<ref>{{Cite web|title = Dependency Injection is Loose Coupling|url = http://blog.ploeh.dk/2010/04/07/DependencyInjectionisLooseCoupling/|website = blog.ploeh.dk|accessdate = 2015-07-28|first = Mark|last = Seemann}}</ref> and to follow the [[dependency inversion principle|dependency inversion]] and [[single responsibility principle]]s.<ref name=MarkSeeman2011P4/><ref>Niko Schwarz, Mircea Lungu, Oscar Nierstrasz, \u201cSeuss: Decoupling responsibilities from static methods for fine-grained configurability\u201d, Journal of Object Technology, Volume 11, no. 1 (April 2012), pp. 3:1-23</ref> It directly contrasts with the [[service locator pattern]], which allows clients to know about the system they use to find dependencies.\n\nAn injection, the basic unit of dependency injection, is not a new or a custom mechanism. It works in the same way that \"[[Parameter (computer programming)|parameter passing]]\" works.<ref>{{Cite web |title = Passing Information to a Method or a Constructor (The Java\u2122 Tutorials > Learning the Java Language > Classes and Objects) |url = https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html |website = docs.oracle.com |accessdate = 2015-07-18}}</ref> Referring to \"parameter passing\" as an injection carries the added implication that it is being done to isolate the client from details.\n\nAn injection is also about what is in control of the passing (never the client) and is independent of how the passing is accomplished, whether by passing a reference or a value.\n\nDependency injection involves four roles:\n* the '''service''' object(s) to be used \n* the '''client''' object that is depending on the service(s) it uses \n* the [[Interface (object-oriented programming)|'''interfaces''']] that define how the client may use the services \n* the '''injector''', which is responsible for constructing the services and injecting them into the client\n\nAs an analogy, \n* service - an electric, gas, hybrid, or diesel car\n* client - a driver who uses the car the same way regardless of the engine\n* interface - [[Automatic_transmission|'''automatic''']], ensures driver does not have to understand engine details like gears\n* injector - the parent who bought the kid the car and decided which kind\n\nAny object that may be used can be considered a '''service'''. Any object that uses other objects can be considered a '''client'''. The names have nothing to do with what the objects are for and everything to do with the role the objects play in any one injection.\n\nThe '''interfaces''' are the types the client expects its dependencies to be. An issue is what they make accessible. They may truly be interface types implemented by the services but also may be abstract classes or even the [[Class (computer programming)#Abstract and Concrete|concrete]] services themselves, though this last would violate [[dependency inversion principle|DIP]]<ref>{{Cite web|title = A curry of Dependency Inversion Principle (DIP), Inversion of Control (IoC), Dependency Injection (DI) and IoC Container - CodeProject|url = http://www.codeproject.com/Articles/538536/A-curry-of-Dependency-Inversion-Principle-DIP-Inve|website = www.codeproject.com|accessdate = 2015-08-08}}</ref> and sacrifice the dynamic decoupling that enables testing. It is only required that the client does not know which they are and therefore never treats them as concrete, say by constructing or extending them.\n\nThe client should have no concrete knowledge of the specific implementation of its dependencies. It should only know the interface's name and [[Application programming interface|API]]. As a result, the client will not need to change even if what is behind the interface changes. However, if the interface is [[Code refactoring|refactored]] from being a class to an interface type (or vice versa) the client will need to be recompiled.<ref>{{Cite web|title = How to force \"program to an interface\" without using a java Interface in java 1.6|url = http://programmers.stackexchange.com/questions/257976/how-to-force-program-to-an-interface-without-using-a-java-interface-in-java-1|website = programmers.stackexchange.com|accessdate = 2015-07-19}}</ref> This is significant if the client and services are published separately. This unfortunate coupling is one that dependency injection cannot resolve.\n\nThe '''injector''' introduces the services into the client. Often, it also constructs the client. An injector may connect together a very complex object graph by treating an object like a client and later as a service for another client. The injector may actually be many objects working together but may not be the client. The injector may be referred to by other names such as: assembler, provider, container, factory, builder, spring, construction code, or main.\n\nDependency injection can be applied as a discipline, one that asks that all objects separate construction and behavior. Relying on a DI framework to perform construction can lead to forbidding the use of the '''new''' keyword, or, less strictly, only allowing direct construction of [[value object]]s.<ref>{{Cite web|title = To \"new\" or not to \"new\"\u2026|url = http://misko.hevery.com/2008/09/30/to-new-or-not-to-new/|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = How to write testable code|url = http://www.loosecouplings.com/2011/01/how-to-write-testable-code-overview.html|website = www.loosecouplings.com|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = Writing Clean, Testable Code|url = http://www.ethanresnick.com/blog/testableCode.html|website = www.ethanresnick.com|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = When to inject: the distinction between newables and injectables - Invisible to the eye|url = http://www.giorgiosironi.com/2009/07/when-to-inject-distinction-between.html|website = www.giorgiosironi.com|accessdate = 2015-07-18|first = Giorgio|last = Sironi}}</ref>\n\n===Taxonomy===\n[[Inversion of control]] (IoC) is more general than dependency injection. Put simply, IoC means letting other code call you rather than insisting on doing the calling. An example of IoC without dependency injection is the [[template method pattern]]. Here, [[Polymorphism (computer science)|polymorphism]] is achieved through [[Inheritance (object-oriented programming)#Subclasses and superclasses|subclassing]], that is, [[Inheritance (object-oriented programming)|inheritance]].<ref>{{Cite web|title = Inversion of Control vs Dependency Injection|url = https://stackoverflow.com/questions/6550700/inversion-of-control-vs-dependency-injection|website = stackoverflow.com|accessdate = 2015-08-05}}</ref>\n \nDependency injection implements IoC through [[Object composition|composition]] so is often identical to that of the [[strategy pattern]], but while the strategy pattern is intended for dependencies to be interchangeable throughout an object's [[Object lifetime|lifetime]], in dependency injection it may be that only a single instance of a dependency is used.<ref>{{Cite web|title = What is the difference between Strategy pattern and Dependency Injection?|url = https://stackoverflow.com/questions/4176520/what-is-the-difference-between-strategy-pattern-and-dependency-injection|website = stackoverflow.com|accessdate = 2015-07-18}}</ref> This still achieves polymorphism, but through [[Delegation pattern|delegation]] and [[Object composition|composition]].\n\n===Dependency injection frameworks===\n[[Application framework]]s such as [http://cdi-spec.org/ CDI] and its implementation [http://weld.cdi-spec.org Weld], [[Spring Framework|Spring]], [[Guice]], [[Play framework]], [https://ruediste.github.io/salta/ Salta], [[HK2 DI Kernel|Glassfish HK2]], [https://google.github.io/dagger/ Dagger], and [[Managed Extensibility Framework]] (MEF) support dependency injection but are not required to do dependency injection.<ref>{{Cite web|title = Dependency Injection != using a DI container|url = http://www.loosecouplings.com/2011/01/dependency-injection-using-di-container.html|website = www.loosecouplings.com|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = Black Sheep \u00bb DIY-DI \u00bb Print|url = http://blacksheep.parry.org/archives/diy-di/print/|website = blacksheep.parry.org|accessdate = 2015-07-18|url-status = dead|archiveurl = https://web.archive.org/web/20150627215638/http://blacksheep.parry.org/archives/diy-di/print|archivedate = 2015-06-27}}</ref>\n\n===Advantages===\n* Dependency injection allows a client the flexibility of being configurable. Only the client's behavior is fixed. The client may act on anything that supports the intrinsic interface the client expects.{{cn|date=July 2019}}\n* Dependency injection can be used to externalize a system's configuration details into configuration files, allowing the system to be reconfigured without recompilation. Separate configurations can be written for different situations that require different implementations of components. This includes, but is not limited to, testing.{{cn|date=July 2019}}\n* Because dependency injection does not require any change in code behavior it can be applied to legacy code as a [[Code refactoring|refactoring]]. The result is clients that are more independent and that are easier to [[Unit testing|unit test]] in isolation using [[Method stub|stubs]] or [[mock object]]s that simulate other objects not under test. This ease of testing is often the first benefit noticed when using dependency injection.{{cn|date=July 2019}}\n*Dependency injection allows a client to remove all knowledge of a concrete implementation that it needs to use. This helps isolate the client from the impact of design changes and defects. It promotes reusability, testability and maintainability.<ref name=\"JSR330\">{{Cite web|title = The Java Community Process(SM) Program - JSRs: Java Specification Requests - detail JSR# 330|url = https://jcp.org/en/jsr/detail?id=330|website = jcp.org|accessdate = 2015-07-18}}</ref>\n*Reduction of [[boilerplate code]] in the application objects, since all work to initialize or set up dependencies is handled by a provider component.<ref name=\"JSR330\"/>\n*Dependency injection allows concurrent or independent development. Two developers can independently develop [[Class (computer programming)|classes]] that use each other, while only needing to know the interface the classes will communicate through. [[Plug-in (computing)|Plugins]] are often developed by third party shops that never even talk to the developers who created the product that uses the plugins.{{cn|date=July 2019}}\n*Dependency Injection decreases coupling between a class and its dependency.<ref>{{Cite web|title = the urban canuk, eh: On Dependency Injection and Violating Encapsulation Concerns|url = http://www.bryancook.net/2011/08/on-dependency-injection-and-violating.html|website = www.bryancook.net|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = The Dependency Injection Design Pattern|url = https://msdn.microsoft.com/en-us/library/vstudio/hh323705(v=vs.100).aspx|website = msdn.microsoft.com|accessdate = 2015-07-18}}</ref>\n\n===Disadvantages===\n\n* Dependency injection creates clients that demand configuration details be supplied by construction code. This can be onerous when obvious defaults are available.{{cn|date=July 2019}}\n* Dependency injection can make code difficult to trace (read) because it separates behavior from construction. This means developers must refer to more files to follow how a system performs.{{cn|date=July 2019}}\n* Dependency injection frameworks are implemented with reflection or dynamic programming. This can hinder use of IDE automation, such as \"find references\", \"show call hierarchy\" and safe refactorings.{{cn|date=July 2019}}\n* Dependency injection typically requires more upfront development effort since one can not summon into being something right when and where it is needed but must ask that it be injected and then ensure that it has been injected.{{cn|date=July 2019}}\n* Dependency injection forces complexity to move out of classes and into the linkages between classes which might not always be desirable or easily managed.<ref name=\"stackoverflow.com\">{{Cite web|title = What are the downsides to using Dependency Injection?|url = https://stackoverflow.com/questions/2407540/what-are-the-downsides-to-using-dependency-injection|website = stackoverflow.com|accessdate = 2015-07-18}}</ref>\n* Dependency injection can encourage dependence on a dependency injection framework.<ref name=\"stackoverflow.com\" /><ref name=\"sites.google.com\">{{Cite web|title = Dependency Injection Inversion - Clean Coder|url = https://sites.google.com/site/unclebobconsultingllc/blogs-by-robert-martin/dependency-injection-inversion|website = sites.google.com|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = Decoupling Your Application From Your Dependency Injection Framework|url = http://www.infoq.com/news/2010/01/dependency-injection-inversion|website = InfoQ|accessdate = 2015-07-18}}</ref>\n\n== Structure ==\n\n=== UML class and sequence diagram ===\n\n[[File:w3sDesign Dependency Injection Design Pattern UML.jpg|frame|none|A sample UML class and sequence diagram for the Dependency Injection design pattern. <ref>{{cite web|title=The Dependency Injection design pattern - Structure and Collaboration|url=http://w3sdesign.com/?gr=u01&ugr=struct|website=w3sDesign.com|accessdate=2017-08-12}}</ref>]]\n\nIn the above [[Unified Modeling Language|UML]] [[class diagram]], the <code>Client</code> class \nthat requires <code>ServiceA</code> and <code>ServiceB</code> objects does not instantiate the <code>ServiceA1</code> and <code>ServiceB1</code> classes directly.\nInstead, an <code>Injector</code> class creates the objects and injects them\ninto the <code>Client</code>, which makes the <code>Client</code> independent of how the objects are created (which concrete classes are instantiated).\n<br>\nThe [[Unified Modeling Language|UML]] [[sequence diagram]] shows the run-time interactions: The <code>Injector</code> object creates the <code>ServiceA1</code> and <code>ServiceB1</code> objects.\nThereafter, the <code>Injector</code> creates the <code>Client</code> object\nand injects the <code>ServiceA1</code> and <code>ServiceB1</code> objects.\n\n==Examples==\n\n=== Without dependency injection ===\nIn the following [[Java (programming language)|Java]] example, the Client class contains a Service [[member variable]] that is initialized by the Client [[Constructor (object-oriented programming)|constructor]]. The client controls which implementation of service is used and controls its construction. In this situation, the client is said to have a hard-coded dependency on ExampleService.\n\n<source lang=\"java\">\n// An example without dependency injection\npublic class Client {\n    // Internal reference to the service used by this client\n    private ExampleService service;\n\n    // Constructor\n    Client() {\n        // Specify a specific implementation in the constructor instead of using dependency injection\n        service = new ExampleService();\n    }\n\n    // Method within this client that uses the services\n    public String greet() {\n        return \"Hello \" + service.getName();\n    }\n}\n</source>\n\nDependency injection is an alternative technique to initialize the member variable rather than explicitly creating a service object as shown above. We can adjust this example using the various techniques described and illustrated in the subsections below.\n\n=== Types of dependency injection ===\nThere are at least three ways a client object can receive a reference to an external module:<ref>{{cite web|author=Martin Fowler |url=http://www.martinfowler.com/articles/injection.html#FormsOfDependencyInjection |title=Inversion of Control Containers and the Dependency Injection pattern - Forms of Dependency Injection |publisher=Martinfowler.com |date=2004-01-23 |accessdate=2014-03-22}}</ref>\n;''constructor injection''\n: The dependencies are provided through a client's class constructor.\n;''setter injection''\n: The client exposes a setter method that the injector uses to inject the dependency.\n;''interface injection''\n: The dependency's interface provides an injector method that will inject the dependency into any client passed to it. Clients must implement an interface that exposes a [[setter method]] that accepts the dependency.\n\n==== Other types   ====\nIt is possible for DI frameworks to have other types of ''injection'' beyond those presented above.<ref>{{cite web |url=http://yan.codehaus.org/Dependency+Injection+Types |title=Yan - Dependency Injection Types |publisher=Yan.codehaus.org |accessdate=2013-12-11 |url-status=dead |archiveurl=https://web.archive.org/web/20130818125650/http://yan.codehaus.org/Dependency%20Injection%20Types |archivedate=2013-08-18 }}</ref>\n\nTesting frameworks may also use other types. Some modern testing frameworks do not even require that clients actively accept dependency injection thus making legacy code testable. In particular, in the Java language it is possible to use reflection to make private attributes public when testing and thus accept injections by assignment.<ref>{{Cite web|title = AccessibleObject (Java Platform SE 7)|url = http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/AccessibleObject.html|website = docs.oracle.com|accessdate = 2015-07-18}}</ref>\n\nSome attempts at Inversion of Control do not provide full removal of dependency, but instead simply substitute one form of dependency for another. As a rule of thumb, if a programmer can look at nothing but the client code and tell what framework is being used, then the client has a hard-coded dependency on the framework.\n\n==== Constructor injection ====\nThis method requires the client to provide a parameter in a [[constructor (object-oriented programming)|constructor]] for the dependency.  \n<source lang=\"java\">\n// Constructor\nClient(Service service) {\n    // Save the reference to the passed-in service inside this client\n    this.service = service;\n}\n</source>\n\n==== Setter injection ====\nThis method requires the client to provide a [[setter method]] for the dependency.  \n<source lang=\"java\">\n// Setter method\npublic void setService(Service service) {\n    // Save the reference to the passed-in service inside this client.\n    this.service = service;\n}\n</source>\n\n==== Interface injection ====\nThis is simply the client publishing a role interface to the setter methods of the client's dependencies. It can be used to establish how the injector should talk to the client when injecting dependencies.\n<source lang=\"java\">\n// Service setter interface.\npublic interface ServiceSetter {\n    public void setService(Service service);\n}\n\n// Client class\npublic class Client implements ServiceSetter {\n    // Internal reference to the service used by this client.\n    private Service service;\n\n    // Set the service that this client is to use.\n    @Override\n    public void setService(Service service) {\n        this.service = service;\n    }\n}\n</source>\n\n==== Constructor injection comparison ====\nPreferred when all dependencies can be constructed first because it can be used to ensure the client object is always in a valid state, as opposed to having some of its dependency references be null (not be set). However, on its own, it lacks the flexibility to have its dependencies changed later. This can be a first step towards making the client [[Immutable object|immutable]] and therefore [[Thread safety|thread safe]].  \n<source lang=\"java\">\n// Constructor\nClient(Service service, Service otherService) {\n    if (service == null) {\n        throw new InvalidParameterException(\"service must not be null\");\n    }\n    if (otherService == null) {\n        throw new InvalidParameterException(\"otherService must not be null\");\n    }\n\n    // Save the service references inside this client\n    this.service = service;\n    this.otherService = otherService;\n}\n</source>\n\n==== Setter injection comparison ====\nRequires the client to provide a setter method for each dependency. This gives the freedom to manipulate the state of the dependency references at any time. This offers flexibility, but if there is more than one dependency to be injected, it is difficult for the client to ensure that all dependencies are injected before the client could be provided for use.\n<source lang=\"java\">\n// Set the service to be used by this client\npublic void setService(Service service) {\n    if (service == null) {\n        throw new InvalidParameterException(\"service must not be null\");\n    }\n    this.service = service;\n}\n\n// Set the other service to be used by this client\npublic void setOtherService(Service otherService) {\n    if (otherService == null) {\n        throw new InvalidParameterException(\"otherService must not be null\");\n    }\n    this.otherService = otherService;\n}\n</source>\nBecause these injections happen independently there is no way to tell when the injector is finished wiring the client. A dependency can be left null simply by the injector failing to call its setter. This forces the check that injection was completed from when the client is assembled to whenever it is used.\n\n<source lang=\"java\">\n// Set the service to be used by this client\npublic void setService(Service service) {\n    this.service = service;\n}\n\n// Set the other service to be used by this client\npublic void setOtherService(Service otherService) {\n    this.otherService = otherService;\n}\n\n// Check the service references of this client\nprivate void validateState() {\n    if (service == null) {\n        throw new IllegalStateException(\"service must not be null\");\n    }\n    if (otherService == null) {\n        throw new IllegalStateException(\"otherService must not be null\");\n    }\n}\n\n// Method that uses the service references\npublic void doSomething() {\n    validateState();\n    service.doYourThing();\n    otherService.doYourThing();\n}\n</source>\n\n==== Interface injection comparison ====\nThe advantage of interface injection is that dependencies can be completely ignorant of their clients yet can still receive a reference to a new client and, using it, send a reference-to-self back to the client. In this way, the dependencies become injectors. The key is that the injecting method (which could just be a classic setter method) is provided through an interface.\n\nAn assembler is still needed to introduce the client and its dependencies. The assembler would take a reference to the client, cast it to the setter interface that sets that dependency, and pass it to that dependency object which would turn around and pass a reference-to-self back to the client.\n\nFor interface injection to have value, the dependency must do something in addition to simply passing back a reference to itself. This could be acting as a factory or sub-assembler to resolve other dependencies, thus abstracting some details from the main assembler. It could be reference-counting so that the dependency knows how many clients are using it. If the dependency maintains a collection of clients, it could later inject them all with a different instance of itself.\n<source lang=\"java\">\n// Service setter interface.\npublic interface ServiceSetter {\n    public void setService(Service service);\n}\n\n// Client class\npublic class Client implements ServiceSetter {\n    // Internal reference to the service used by this client.\n    private Service service;\n\n    // Set the service that this client is to use.\n    @Override\n    public void setService(Service service) {\n        this.service = service;\n    }\n}\n\n// Injector class\npublic class ServiceInjector {\n\tSet<ServiceSetter> clients;\n\tpublic void inject(ServiceSetter client) {\n\t\tclients.add(client);\n\t\tclient.setService(new ServiceFoo());\n\t}\n\tpublic void switchToBar() {\n\t\tfor (Client client : clients) {\n\t\t\tclient.setService(new ServiceBar());\n\t\t}\n\t}\n}\n\n// Service classes\npublic class ServiceFoo implements Service {}\npublic class ServiceBar implements Service {}\n</source>\n\n=== Assembling examples ===\nManually assembling in main by hand is one way of implementing dependency injection.\n\n<source lang=\"java\">\npublic class Injector {\n    public static void main(String[] args) {\n        // Build the dependencies first\n        Service service = new ExampleService();\n\n        // Inject the service, constructor style\n        Client client = new Client(service);\n\n        // Use the objects\n        System.out.println(client.greet());\n    }\t\n}\n</source>\nThe example above constructs the object graph manually and then invokes it at one point to start it working. Important to note is that this injector is not pure. It uses one of the objects it constructs. It has a purely construction-only relationship with ExampleService but mixes construction and using of Client. This should not be common. It is, however, unavoidable. Just like object oriented software needs a non-object oriented static method like main() to get started, a dependency injected object graph needs at least one (preferably only one) entry point to get the whole thing started.\n\nManual construction in the main method may not be this straight forward and may involve calling [[Builder pattern|builders]], [[Factory (object-oriented programming)|factories]], or other [[Creational pattern|construction patterns]] as well. This can be fairly advanced and abstract. The line is crossed from manual dependency injection to [[Software framework|framework]] dependency injection once the constructing code is no longer custom to the application and is instead universal.<ref>{{citation|url=http://www.riehle.org/computer-science/research/dissertation/diss-a4.pdf|first=Dirk|last=Riehle|title=Framework Design: A Role Modeling Approach|publisher=[[ETH Zurich|Swiss Federal Institute of Technology]]|year=2000|postscript=<!--none-->}}</ref>\n\nFrameworks like [[Spring Framework|Spring]] can construct these same objects and wire them together before returning a reference to client. All mention of the concrete ExampleService can be moved from the code to the configuration data.\n\n<source lang=\"java\">\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Injector {\n\tpublic static void main(String[] args) {\n\t\t// -- Assembling objects -- //\n\t\tBeanFactory beanfactory = new ClassPathXmlApplicationContext(\"Beans.xml\");\n\t\tClient client = (Client) beanfactory.getBean(\"client\");\n\n\t\t// -- Using objects -- //\n\t\tSystem.out.println(client.greet());\n\t}\n}\n</source>\n\nFrameworks like Spring allow assembly details to be externalized in configuration files.\nThis code (above) constructs objects and wires them together according to Beans.xml (below). ExampleService is still constructed even though it is only mentioned below. A long and complex object graph can be defined this way and the only class mentioned in code would be the one with the entry point method, which in this case is greet().\n\n<source lang=\"xml\">\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n    <bean id=\"service\" class=\"ExampleService\">\n    </bean>\n\n    <bean id=\"client\" class=\"Client\">\n        <constructor-arg value=\"service\" />        \n    </bean>\n</beans>\n</source>\n\nIn the example above Client and Service have not had to undergo any changes to be provided by spring. They are allowed to remain simple [[Plain Old Java Object|POJO]]s.<ref>{{Cite web|title = Spring Tips: A POJO with annotations is not Plain|url = http://springtips.blogspot.com/2007/07/pojo-with-annotations-is-not-plain.html|accessdate = 2015-07-18|archive-url = https://web.archive.org/web/20150715045353/http://springtips.blogspot.com/2007/07/pojo-with-annotations-is-not-plain.html|archive-date = 2015-07-15|url-status = dead}}</ref><ref>{{Cite web|title = Annotations in POJO \u2013 a boon or a curse? {{!}} Techtracer|url = http://techtracer.com/2007/04/07/annotations-in-pojo-a-boon-or-a-curse/|accessdate = 2015-07-18|date = 2007-04-07}}</ref><ref>\n{{cite book\n|url=https://books.google.com/?id=FCVnsq1ZUI0C&pg=PA64&lpg=PA64&dq=spring+pojo+annotation+free#v=onepage&q=spring%20pojo%20annotation%20free&f=false|title=Pro Spring Dynamic Modules for OSGi Service Platforms|publisher=APress |accessdate=2015-07-06|isbn=9781430216124|date=2009-02-17}}\n</ref> This shows how spring can connect services and clients that are completely ignorant of its existence. This could not be said if spring annotations are added to the classes. By keeping spring specific annotations and calls from spreading out among many classes, the system stays only loosely dependent on spring.<ref name=\"sites.google.com\"/> This can be important if the system intends to outlive spring.\n\nThe choice to keep POJOs pure does not come without cost. Rather than spending the effort to develop and maintain complex configuration files it is possible to simply use annotations to mark classes and let spring do the rest of the work. Resolving dependencies can be simple if they follow a convention such as matching by type or by name. This is choosing [[convention over configuration]].<ref>{{Cite web|title = Captain Debug's Blog: Is 'Convention Over Configuration' Going Too Far?|url = http://www.captaindebug.com/2011/08/is-convention-over-configuration-going.html#.VapTMvlVhHx|website = www.captaindebug.com|accessdate = 2015-07-18}}</ref> It is also arguable that, when refactoring to another framework, removing framework specific annotations would be a trivial part of the task<ref>{{Cite web|title = What's the issue with @Inject? {{!}} Colin's Devlog|url = http://blog.cgdecker.com/2010/01/whats-issue-with-inject.html|website = blog.cgdecker.com|accessdate = 2015-07-18|first = Colin|last = Decker}}</ref> and many injection annotations are now standardized.<ref>{{Cite web|title = Dagger - A new Java dependency injection framework|url = http://musingsofaprogrammingaddict.blogspot.com/2012/11/dagger-new-java-dependency-injection.html|website = Dagger - A new Java dependency injection framework - Musings of a Programming Addict|date = 2012-11-18|accessdate = 2015-07-18|first = Gunnar|last = Morling}}</ref><ref>{{Cite web|title = The Java Community Process(SM) Program - JSRs: Java Specification Requests - detail JSR# 330|url = https://www.jcp.org/en/jsr/detail?id=330|website = www.jcp.org|accessdate = 2015-07-18}}</ref>\n\n<source lang=\"java\">\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class Injector {\n\tpublic static void main(String[] args) {\n\t\t// Assemble the objects\n\t\tBeanFactory beanfactory = new AnnotationConfigApplicationContext(MyConfiguration.class);\n\t\tClient client = beanfactory.getBean(Client.class);\n\n\t\t// Use the objects\n\t\tSystem.out.println(client.greet());\n\t}\n}\n</source>\n\n<source lang=\"java\">\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@ComponentScan\npublic class MyConfiguration {\n    @Bean\n    public Client client(ExampleService service) {\n        return new Client(service);\n    }\n}\n</source>\n\n<source lang=\"java\">\n@Component\npublic class ExampleService {\n    public String getName() {\n        return \"World!\";\n    }\n}\n</source>\n\n=== Assembly comparison ===\nThe different injector implementations (factories, [[Service locator pattern|service locator]]s, and dependency injection containers) are not that different as far as dependency injection is concerned. What makes all the difference is where they are allowed to be used. Move calls to a factory or a service locator out of the client and into main and suddenly main makes a fairly good dependency injection container.\n\nBy moving all knowledge of the injector out, a clean client, free of knowledge of the outside world, is left behind. However, any object that uses other objects can be considered a client. The object that contains main is no exception. This main object is not using dependency injection. It is actually using the service locator pattern. This can not be avoided because the choice of service implementations must be made somewhere.\n\nExternalizing the dependencies into configuration files does not change this fact. What makes this reality part of a good design is that the service locator is not spread throughout the code base. It is confined to one place per application. This leaves the rest of the code base free to use dependency injection to make clean clients.\n\n=== Dependency Injection Pattern ===\n\nThe examples until now have been overly simple examples about constructing a string. However, the dependency injection pattern is most useful when constructing an object graph where objects communicate via messages. Objects constructed in main will last for the life of the program. The typical pattern is to construct the graph and then call one method on one object to send the flow of control into the object graph. Just as main is the entry point to the static code, this one method is the entry point to the applications non-static code.\n\n<source lang=\"java\">\npublic static void main(String[] args) throws IOException {\n\n    // Construction code. \n    Greeter greeter = new Greeter(System.out); // This may be many lines that connect many objects\n    \n    // Behavior code.\n    greeter.greet(); // This is one call to one method on one object in the object graph\n}\n\nclass Greeter {\n    public void greet() {\n        this.out.println(\"Hello world!\");\n    }\n    public Greeter(PrintStream out) {\n        this.out = out;\n    }\n    private PrintStream out;\n}\n\n</source>\n\n===AngularJS example===\nIn the [[AngularJS]] framework, there are only three ways a component (object or function) can directly access its dependencies:\n\n# The component can create the dependency, typically using the <code>new</code> operator.\n# The component can look up the dependency, by referring to a global variable.\n# The component can have the dependency passed to it where it is needed.\nThe first two options of creating or looking up dependencies are not optimal because they hard code the dependency to the component. This makes it difficult, if not impossible, to modify the dependencies. This is especially problematic in tests, where it is often desirable to provide mock dependencies for test isolation.\n\nThe third option is the most viable, since it removes the responsibility of locating the dependency from the component. The dependency is simply handed to the component.\n\n<source lang=\"JavaScript\">\nfunction SomeClass(greeter) {\n  this.greeter = greeter;\n}\n\nSomeClass.prototype.doSomething = function(name) {\n  this.greeter.greet(name);\n}\n</source>\n\nIn the above example <code>SomeClass</code> is not concerned with creating or locating the greeter dependency, it is simply handed the greeter when it is instantiated.\n\nThis is desirable, but it puts the responsibility of getting hold of the dependency on the code that constructs <code>SomeClass</code>.\n\nTo manage the responsibility of dependency creation, each AngularJS application has an injector. The injector is a service locator that is responsible for construction and look-up of dependencies.\n\nHere is an example of using the injector service:\n\n<source lang=\"JavaScript\">\n// Provide the wiring information in a module\nvar myModule = angular.module('myModule', []);\n\n// Teach the injector how to build a greeter service. \n// greeter is dependent on the $window service. \n// The greeter service is an object that\n// contains a greet method.\nmyModule.factory('greeter', function($window) {\n  return {\n    greet: function(text) {\n      $window.alert(text);\n    }\n  };\n});\n</source>\n\nCreate a new injector that can provide components defined in the <code>myModule</code> module and request our greeter service from the injector. (This is usually done automatically by the AngularJS bootstrap).\n\n<source lang=\"JavaScript\">\nvar injector = angular.injector(['myModule', 'ng']);\nvar greeter = injector.get('greeter');\n</source>\n\nAsking for dependencies solves the issue of hard coding, but it also means that the injector needs to be passed throughout the application. Passing the injector breaks the [[Law of Demeter]]. To remedy this, we use a declarative notation in our HTML templates, to hand the responsibility of creating components over to the injector, as in this example:\n\n<source lang=\"html\">\n<div ng-controller=\"MyController\">\n  <button ng-click=\"sayHello()\">Hello</button>\n</div>\n</source>\n<source lang=\"JavaScript\">\nfunction MyController($scope, greeter) {\n  $scope.sayHello = function() {\n    greeter.greet('Hello World');\n  };\n}\n</source>\nWhen AngularJS compiles the HTML, it processes the <code>ng-controller</code> directive, which in turn asks the injector to create an instance of the controller and its dependencies.\n\n injector.instantiate(MyController);\nThis is all done behind the scenes. Because the <code>ng-controller</code> defers to the injector to instantiate the class, it can satisfy all of the dependencies of <code>MyController</code> without the controller ever knowing about the injector. The application code simply declares the dependencies it needs, without having to deal with the injector. This setup does not break the [[Law of Demeter]].\n\n==See also==\n* [[Architecture description language]]\n* [[Factory pattern]]\n* [[Inversion of control]]\n* [[Plug-in (computing)]]\n* [[Strategy pattern]]\n* [[AngularJS]]\n* [[Service locator pattern]]\n* [[Parameter (computer programming)]]\n* [[Quaject]]\n\n==References==\n{{Reflist}}\n\n==External links==\n{{Commons category|Dependency injection}}\n* [http://blog.ploeh.dk/2011/07/28/CompositionRoot/ Composition Root by Mark Seemann]\n* [http://www.theserverside.com/tt/articles/article.tss?l=IOCBeginners A beginners guide to Dependency Injection]\n* [http://www.ddj.com/185300375 Dependency Injection & Testable Objects: Designing loosely coupled and testable objects] - Jeremy Weiskotten; [[Dr. Dobb's Journal]], May 2006.\n* [http://www.griffincaprio.com/blog/2018/04/design-patterns-dependency-injection.html Design Patterns: Dependency Injection -- MSDN Magazine, September 2005]\n* [http://martinfowler.com/articles/injection.html Martin Fowler's original article that introduced the term Dependency Injection]\n* [http://martinfowler.com/eaaCatalog/plugin.html P of EAA: Plugin]\n* [http://www.javalobby.org/articles/di-heritage/ The Rich Engineering Heritage Behind Dependency Injection] - [[Andrew McVeigh]] - A detailed history of dependency injection.\n* [http://tutorials.jenkov.com/dependency-injection/index.html What is Dependency Injection?] - An alternative explanation - Jakob Jenkov\n* [http://www.developer.com/net/net/article.php/3636501 Writing More Testable Code with Dependency Injection -- Developer.com, October 2006]\n* [http://msdn.microsoft.com/en-us/library/dd460648.aspx Managed Extensibility Framework Overview -- MSDN]\n* [https://web.archive.org/web/20120425150101/http://www.midmarsh.co.uk/planetjava/tutorials/language/WatchingtheObservables.PDF Old fashioned description of the Dependency Mechanism by Hunt 1998] \n* [http://blog.thecodewhisperer.com/2011/12/07/refactor-your-way-to-a-dependency-injection-container/ Refactor Your Way to a Dependency Injection Container]\n* [http://php-di.org/doc/understanding-di.html Understanding DI in PHP]\n* [https://medium.com/@wrong.about/you-dont-need-a-dependency-injection-container-10a5d4a5f878 You Don't Need a Dependency Injection Container]\n{{Design Patterns patterns}}\n\n<!-- Interwikies -->\n\n{{DEFAULTSORT:Dependency Injection}}\n[[Category:Component-based software engineering]]\n[[Category:Software architecture]]\n[[Category:Software design patterns]]\n[[Category:Articles with example Java code]]\n", "text_old": "{{Refimprove|date=July 2019}}\nIn [[software engineering]], '''dependency injection''' is a technique whereby one [[Object (computer science)|object]] supplies the dependencies of another object. A \"dependency\" is an object that can be used, for example as a [[Service (systems architecture)|service]]. Instead of a client specifying which service it will use, something tells the client what service to use. The \"injection\" refers to the passing of a dependency (a service) into the object (a [[Client (computing)|client]]) that would use it. The service is made part of the client's [[State (computer science)|state]].<ref name=\"JamesShore\">{{Cite web|title = James Shore: Dependency Injection Demystified|url = http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html|website = www.jamesshore.com|accessdate = 2015-07-18|first = Titanium|last = I.T.}}</ref> Passing the service to the client, rather than allowing a client to build or [[Service locator pattern|find the service]], is the fundamental requirement of the pattern.\n\nThe intent behind dependency injection is to achieve [[Separation of Concerns]] of construction and use of objects. This can increase readability and code reuse.\n\nDependency injection is one form of the broader technique of [[inversion of control]]. A client who wants to call some services should not have to know how to construct those services. Instead, the client delegates the responsibility of providing its services to external code (the injector). The client is not allowed to call the injector code;<ref name=\"HollywoodPrinciple.c2\">{{Cite web|title = HollywoodPrinciple|url = http://c2.com/cgi/wiki?HollywoodPrinciple|website = c2.com|accessdate = 2015-07-19}}</ref> it is the injector that constructs the services. The injector then injects (passes) the services into the client which might already exist or may also be constructed by the injector. The client then uses the services. This means the client does not need to know about the injector, how to construct the services, or even which actual services it is using. The client only needs to know about the intrinsic interfaces of the services because these define how the client may use the services. This separates the responsibility of \"use\" from the responsibility of \"construction\".\n\n==Intent==\n\nDependency Injection solves problems such as:<ref>{{cite web|title=The Dependency Injection design pattern - Problem, Solution, and Applicability|url=http://w3sdesign.com/?gr=u01&ugr=proble|website=w3sDesign.com|accessdate=2017-08-12}}</ref>\n\n* How can an application or [[Class (computer programming)|class]] be independent of how its objects are created?\n* How can the way objects are created be specified in separate configuration files?\n* How can an application support different configurations?\n\nCreating objects directly within the class that requires the objects be inflexible because it commits the class to particular objects and makes it impossible to change the instantiation later independently from (without having to change) the class. It stops the class from being reusable if other objects are required, and it makes the class hard to test because real objects can not be replaced with mock objects.\n\nA class is no longer responsible for creating the objects it requires, and it does not have to delegate instantiation to a factory object as in the [[Abstract_factory_pattern|Abstract Factory]]<ref name=\"GoF\">{{cite book|author=Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides|title=Design Patterns: Elements of Reusable Object-Oriented Software|year=1994|publisher=Addison Wesley|isbn=0-201-63361-2|pages=[https://archive.org/details/designpatternsel00gamm/page/87 87ff]|url-access=registration|url=https://archive.org/details/designpatternsel00gamm/page/87}}</ref> design pattern.<br>See also the UML class and sequence diagram below.\n\n==Overview==\n{{Quote box\n| quote = '''Dependency injection for five-year-olds'''\n\nWhen you go and get things out of the refrigerator for yourself, you can cause problems. You might leave the door open, you might get something Mommy or Daddy doesn't want you to have. You might even be looking for something we don't even have or which has expired.\n\nWhat you should be doing is stating a need, \"I need something to drink with lunch,\" and then we will make sure you have something when you sit down to eat.\n|source=John Munsch, 28 October 2009.<ref name=MarkSeeman2011P4>{{cite book|last1=Seeman|first1=Mark|title=Dependency Injection in .NET|date=October 2011|publisher=Manning Publications|isbn=9781935182504|page=4}}<!--|accessdate=18 July 2015--></ref><ref>{{Cite web|title = Dependency Injection in NET|url = http://philkildea.co.uk/james/books/Dependency.Injection.in.NET.pdf|page=4|website = philkildea.co.uk|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = How to explain dependency injection to a 5-year-old?|url = https://stackoverflow.com/questions/1638919/how-to-explain-dependency-injection-to-a-5-year-old|website = stackoverflow.com|accessdate = 2015-07-18}}</ref>\n| align = right\n| width = 33%\n}}\n\nDependency injection separates the creation of a client's dependencies from the client's behavior, which allows program designs to be [[Loose coupling|loosely]] [[Coupling (computer programming)|coupled]]<ref>{{Cite web|title = Dependency Injection is Loose Coupling|url = http://blog.ploeh.dk/2010/04/07/DependencyInjectionisLooseCoupling/|website = blog.ploeh.dk|accessdate = 2015-07-28|first = Mark|last = Seemann}}</ref> and to follow the [[dependency inversion principle|dependency inversion]] and [[single responsibility principle]]s.<ref name=MarkSeeman2011P4/><ref>Niko Schwarz, Mircea Lungu, Oscar Nierstrasz, \u201cSeuss: Decoupling responsibilities from static methods for fine-grained configurability\u201d, Journal of Object Technology, Volume 11, no. 1 (April 2012), pp. 3:1-23</ref> It directly contrasts with the [[service locator pattern]], which allows clients to know about the system they use to find dependencies.\n\nAn injection, the basic unit of dependency injection, is not a new or a custom mechanism. It works in the same way that \"[[Parameter (computer programming)|parameter passing]]\" works.<ref>{{Cite web |title = Passing Information to a Method or a Constructor (The Java\u2122 Tutorials > Learning the Java Language > Classes and Objects) |url = https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html |website = docs.oracle.com |accessdate = 2015-07-18}}</ref> Referring to \"parameter passing\" as an injection carries the added implication that it is being done to isolate the client from details.\n\nAn injection is also about what is in control of the passing (never the client) and is independent of how the passing is accomplished, whether by passing a reference or a value.\n\nDependency injection involves four roles:\n* the '''service''' object(s) to be used \n* the '''client''' object that is depending on the service(s) it uses \n* the [[Interface (object-oriented programming)|'''interfaces''']] that define how the client may use the services \n* the '''injector''', which is responsible for constructing the services and injecting them into the client\n\nAs an analogy, \n* service - an electric, gas, hybrid, or diesel car\n* client - a driver who uses the car the same way regardless of the engine\n* interface - [[Automatic_transmission|'''automatic''']], ensures driver does not have to understand engine details like gears\n* injector - the parent who bought the kid the car and decided which kind\n\nAny object that may be used can be considered a '''service'''. Any object that uses other objects can be considered a '''client'''. The names have nothing to do with what the objects are for and everything to do with the role the objects play in any one injection.\n\nThe '''interfaces''' are the types the client expects its dependencies to be. An issue is what they make accessible. They may truly be interface types implemented by the services but also may be abstract classes or even the [[Class (computer programming)#Abstract and Concrete|concrete]] services themselves, though this last would violate [[dependency inversion principle|DIP]]<ref>{{Cite web|title = A curry of Dependency Inversion Principle (DIP), Inversion of Control (IoC), Dependency Injection (DI) and IoC Container - CodeProject|url = http://www.codeproject.com/Articles/538536/A-curry-of-Dependency-Inversion-Principle-DIP-Inve|website = www.codeproject.com|accessdate = 2015-08-08}}</ref> and sacrifice the dynamic decoupling that enables testing. It is only required that the client does not know which they are and therefore never treats them as concrete, say by constructing or extending them.\n\nThe client should have no concrete knowledge of the specific implementation of its dependencies. It should only know the interface's name and [[Application programming interface|API]]. As a result, the client will not need to change even if what is behind the interface changes. However, if the interface is [[Code refactoring|refactored]] from being a class to an interface type (or vice versa) the client will need to be recompiled.<ref>{{Cite web|title = How to force \"program to an interface\" without using a java Interface in java 1.6|url = http://programmers.stackexchange.com/questions/257976/how-to-force-program-to-an-interface-without-using-a-java-interface-in-java-1|website = programmers.stackexchange.com|accessdate = 2015-07-19}}</ref> This is significant if the client and services are published separately. This unfortunate coupling is one that dependency injection cannot resolve.\n\nThe '''injector''' introduces the services into the client. Often, it also constructs the client. An injector may connect together a very complex object graph by treating an object like a client and later as a service for another client. The injector may actually be many objects working together but may not be the client. The injector may be referred to by other names such as: assembler, provider, container, factory, builder, spring, construction code, or main.\n\nDependency injection can be applied as a discipline, one that asks that all objects separate construction and behavior. Relying on a DI framework to perform construction can lead to forbidding the use of the '''new''' keyword, or, less strictly, only allowing direct construction of [[value object]]s.<ref>{{Cite web|title = To \"new\" or not to \"new\"\u2026|url = http://misko.hevery.com/2008/09/30/to-new-or-not-to-new/|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = How to write testable code|url = http://www.loosecouplings.com/2011/01/how-to-write-testable-code-overview.html|website = www.loosecouplings.com|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = Writing Clean, Testable Code|url = http://www.ethanresnick.com/blog/testableCode.html|website = www.ethanresnick.com|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = When to inject: the distinction between newables and injectables - Invisible to the eye|url = http://www.giorgiosironi.com/2009/07/when-to-inject-distinction-between.html|website = www.giorgiosironi.com|accessdate = 2015-07-18|first = Giorgio|last = Sironi}}</ref>\n\n===Taxonomy===\n[[Inversion of control]] (IoC) is more general than dependency injection. Put simply, IoC means letting other code call you rather than insisting on doing the calling. An example of IoC without dependency injection is the [[template method pattern]]. Here, [[Polymorphism (computer science)|polymorphism]] is achieved through [[Inheritance (object-oriented programming)#Subclasses and superclasses|subclassing]], that is, [[Inheritance (object-oriented programming)|inheritance]].<ref>{{Cite web|title = Inversion of Control vs Dependency Injection|url = https://stackoverflow.com/questions/6550700/inversion-of-control-vs-dependency-injection|website = stackoverflow.com|accessdate = 2015-08-05}}</ref>\n \nDependency injection implements IoC through [[Object composition|composition]] so is often identical to that of the [[strategy pattern]], but while the strategy pattern is intended for dependencies to be interchangeable throughout an object's [[Object lifetime|lifetime]], in dependency injection it may be that only a single instance of a dependency is used.<ref>{{Cite web|title = What is the difference between Strategy pattern and Dependency Injection?|url = https://stackoverflow.com/questions/4176520/what-is-the-difference-between-strategy-pattern-and-dependency-injection|website = stackoverflow.com|accessdate = 2015-07-18}}</ref> This still achieves polymorphism, but through [[Delegation pattern|delegation]] and [[Object composition|composition]].\n\n===Dependency injection frameworks===\n[[Application framework]]s such as [http://cdi-spec.org/ CDI] and its implementation [http://weld.cdi-spec.org Weld], [[Spring Framework|Spring]], [[Guice]], [[Play framework]], [https://ruediste.github.io/salta/ Salta], [[HK2 DI Kernel|Glassfish HK2]], [https://google.github.io/dagger/ Dagger], and [[Managed Extensibility Framework]] (MEF) support dependency injection but are not required to do dependency injection.<ref>{{Cite web|title = Dependency Injection != using a DI container|url = http://www.loosecouplings.com/2011/01/dependency-injection-using-di-container.html|website = www.loosecouplings.com|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = Black Sheep \u00bb DIY-DI \u00bb Print|url = http://blacksheep.parry.org/archives/diy-di/print/|website = blacksheep.parry.org|accessdate = 2015-07-18|url-status = dead|archiveurl = https://web.archive.org/web/20150627215638/http://blacksheep.parry.org/archives/diy-di/print|archivedate = 2015-06-27}}</ref>\n\n===Advantages===\n* Dependency injection allows a client the flexibility of being configurable. Only the client's behavior is fixed. The client may act on anything that supports the intrinsic interface the client expects.{{cn|date=July 2019}}\n* Dependency injection can be used to externalize a system's configuration details into configuration files, allowing the system to be reconfigured without recompilation. Separate configurations can be written for different situations that require different implementations of components. This includes, but is not limited to, testing.{{cn|date=July 2019}}\n* Because dependency injection does not require any change in code behavior it can be applied to legacy code as a [[Code refactoring|refactoring]]. The result is clients that are more independent and that are easier to [[Unit testing|unit test]] in isolation using [[Method stub|stubs]] or [[mock object]]s that simulate other objects not under test. This ease of testing is often the first benefit noticed when using dependency injection.{{cn|date=July 2019}}\n*Dependency injection allows a client to remove all knowledge of a concrete implementation that it needs to use. This helps isolate the client from the impact of design changes and defects. It promotes reusability, testability and maintainability.<ref name=\"JSR330\">{{Cite web|title = The Java Community Process(SM) Program - JSRs: Java Specification Requests - detail JSR# 330|url = https://jcp.org/en/jsr/detail?id=330|website = jcp.org|accessdate = 2015-07-18}}</ref>\n*Reduction of [[boilerplate code]] in the application objects, since all work to initialize or set up dependencies is handled by a provider component.<ref name=\"JSR330\"/>\n*Dependency injection allows concurrent or independent development. Two developers can independently develop [[Class (computer programming)|classes]] that use each other, while only needing to know the interface the classes will communicate through. [[Plug-in (computing)|Plugins]] are often developed by third party shops that never even talk to the developers who created the product that uses the plugins.{{cn|date=July 2019}}\n*Dependency Injection decreases coupling between a class and its dependency.<ref>{{Cite web|title = the urban canuk, eh: On Dependency Injection and Violating Encapsulation Concerns|url = http://www.bryancook.net/2011/08/on-dependency-injection-and-violating.html|website = www.bryancook.net|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = The Dependency Injection Design Pattern|url = https://msdn.microsoft.com/en-us/library/vstudio/hh323705(v=vs.100).aspx|website = msdn.microsoft.com|accessdate = 2015-07-18}}</ref>\n\n===Disadvantages===\n\n* Dependency injection creates clients that demand configuration details be supplied by construction code. This can be onerous when obvious defaults are available.{{cn|date=July 2019}}\n* Dependency injection can make code difficult to trace (read) because it separates behavior from construction. This means developers must refer to more files to follow how a system performs.{{cn|date=July 2019}}\n* Dependency injection frameworks are implemented with reflection or dynamic programming. This can hinder use of IDE automation, such as \"find references\", \"show call hierarchy\" and safe refactorings.{{cn|date=July 2019}}\n* Dependency injection typically requires more upfront development effort since one can not summon into being something right when and where it is needed but must ask that it be injected and then ensure that it has been injected.{{cn|date=July 2019}}\n* Dependency injection forces complexity to move out of classes and into the linkages between classes which might not always be desirable or easily managed.<ref name=\"stackoverflow.com\">{{Cite web|title = What are the downsides to using Dependency Injection?|url = https://stackoverflow.com/questions/2407540/what-are-the-downsides-to-using-dependency-injection|website = stackoverflow.com|accessdate = 2015-07-18}}</ref>\n* Dependency injection can encourage dependence on a dependency injection framework.<ref name=\"stackoverflow.com\" /><ref name=\"sites.google.com\">{{Cite web|title = Dependency Injection Inversion - Clean Coder|url = https://sites.google.com/site/unclebobconsultingllc/blogs-by-robert-martin/dependency-injection-inversion|website = sites.google.com|accessdate = 2015-07-18}}</ref><ref>{{Cite web|title = Decoupling Your Application From Your Dependency Injection Framework|url = http://www.infoq.com/news/2010/01/dependency-injection-inversion|website = InfoQ|accessdate = 2015-07-18}}</ref>\n\n== Structure ==\n\n=== UML class and sequence diagram ===\n\n[[File:w3sDesign Dependency Injection Design Pattern UML.jpg|frame|none|A sample UML class and sequence diagram for the Dependency Injection design pattern. <ref>{{cite web|title=The Dependency Injection design pattern - Structure and Collaboration|url=http://w3sdesign.com/?gr=u01&ugr=struct|website=w3sDesign.com|accessdate=2017-08-12}}</ref>]]\n\nIn the above [[Unified Modeling Language|UML]] [[class diagram]], the <code>Client</code> class \nthat requires <code>ServiceA</code> and <code>ServiceB</code> objects does not instantiate the <code>ServiceA1</code> and <code>ServiceB1</code> classes directly.\nInstead, an <code>Injector</code> class creates the objects and injects them\ninto the <code>Client</code>, which makes the <code>Client</code> independent of how the objects are created (which concrete classes are instantiated).\n<br>\nThe [[Unified Modeling Language|UML]] [[sequence diagram]] shows the run-time interactions: The <code>Injector</code> object creates the <code>ServiceA1</code> and <code>ServiceB1</code> objects.\nThereafter, the <code>Injector</code> creates the <code>Client</code> object\nand injects the <code>ServiceA1</code> and <code>ServiceB1</code> objects.\n\n==Examples==\n\n=== Without dependency injection ===\nIn the following [[Java (programming language)|Java]] example, the Client class contains a Service [[member variable]] that is initialized by the Client [[Constructor (object-oriented programming)|constructor]]. The client controls which implementation of service is used and controls its construction. In this situation, the client is said to have a hard-coded dependency on ExampleService.\n\n<source lang=\"java\">\n// An example without dependency injection\npublic class Client {\n    // Internal reference to the service used by this client\n    private ExampleService service;\n\n    // Constructor\n    Client() {\n        // Specify a specific implementation in the constructor instead of using dependency injection\n        service = new ExampleService();\n    }\n\n    // Method within this client that uses the services\n    public String greet() {\n        return \"Hello \" + service.getName();\n    }\n}\n</source>\n\nDependency injection is an alternative technique to initialize the member variable rather than explicitly creating a service object as shown above. We can adjust this example using the various techniques described and illustrated in the subsections below.\n\n=== Types of dependency injection ===\nThere are at least three ways a client object can receive a reference to an external module:<ref>{{cite web|author=Martin Fowler |url=http://www.martinfowler.com/articles/injection.html#FormsOfDependencyInjection |title=Inversion of Control Containers and the Dependency Injection pattern - Forms of Dependency Injection |publisher=Martinfowler.com |date=2004-01-23 |accessdate=2014-03-22}}</ref>\n;''constructor injection''\n: The dependencies are provided through a client's class constructor.\n;''setter injection''\n: The client exposes a setter method that the injector uses to inject the dependency.\n;''interface injection''\n: The dependency's interface provides an injector method that will inject the dependency into any client passed to it. Clients must implement an interface that exposes a [[setter method]] that accepts the dependency.\n\n==== Other types   ====\nIt is possible for DI frameworks to have other types of ''injection'' beyond those presented above.<ref>{{cite web |url=http://yan.codehaus.org/Dependency+Injection+Types |title=Yan - Dependency Injection Types |publisher=Yan.codehaus.org |accessdate=2013-12-11 |url-status=dead |archiveurl=https://web.archive.org/web/20130818125650/http://yan.codehaus.org/Dependency%20Injection%20Types |archivedate=2013-08-18 }}</ref>\n\nTesting frameworks may also use other types. Some modern testing frameworks do not even require that clients actively accept dependency injection thus making legacy code testable. In particular, in the Java language it is possible to use reflection to make private attributes public when testing and thus accept injections by assignment.<ref>{{Cite web|title = AccessibleObject (Java Platform SE 7)|url = http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/AccessibleObject.html|website = docs.oracle.com|accessdate = 2015-07-18}}</ref>\n\nSome attempts at Inversion of Control do not provide full removal of dependency, but instead simply substitute one form of dependency for another. As a rule of thumb, if a programmer can look at nothing but the client code and tell what framework is being used, then the client has a hard-coded dependency on the framework.\n\n==== Constructor injection ====\nThis method requires the client to provide a parameter in a [[constructor (object-oriented programming)|constructor]] for the dependency.  \n<source lang=\"java\">\n// Constructor\nClient(Service service) {\n    // Save the reference to the passed-in service inside this client\n    this.service = service;\n}\n</source>\n\n==== Setter injection ====\nThis method requires the client to provide a [[setter method]] for the dependency.  \n<source lang=\"java\">\n// Setter method\npublic void setService(Service service) {\n    // Save the reference to the passed-in service inside this client.\n    this.service = service;\n}\n</source>\n\n==== Interface injection ====\nThis is simply the client publishing a role interface to the setter methods of the client's dependencies. It can be used to establish how the injector should talk to the client when injecting dependencies.\n<source lang=\"java\">\n// Service setter interface.\npublic interface ServiceSetter {\n    public void setService(Service service);\n}\n\n// Client class\npublic class Client implements ServiceSetter {\n    // Internal reference to the service used by this client.\n    private Service service;\n\n    // Set the service that this client is to use.\n    @Override\n    public void setService(Service service) {\n        this.service = service;\n    }\n}\n</source>\n\n==== Constructor injection comparison ====\nPreferred when all dependencies can be constructed first because it can be used to ensure the client object is always in a valid state, as opposed to having some of its dependency references be null (not be set). However, on its own, it lacks the flexibility to have its dependencies changed later. This can be a first step towards making the client [[Immutable object|immutable]] and therefore [[Thread safety|thread safe]].  \n<source lang=\"java\">\n// Constructor\nClient(Service service, Service otherService) {\n    if (service == null) {\n        throw new InvalidParameterException(\"service must not be null\");\n    }\n    if (otherService == null) {\n        throw new InvalidParameterException(\"otherService must not be null\");\n    }\n\n    // Save the service references inside this client\n    this.service = service;\n    this.otherService = otherService;\n}\n</source>\n\n==== Setter injection comparison ====\nRequires the client to provide a setter method for each dependency. This gives the freedom to manipulate the state of the dependency references at any time. This offers flexibility, but if there is more than one dependency to be injected, it is difficult for the client to ensure that all dependencies are injected before the client could be provided for use.\n<source lang=\"java\">\n// Set the service to be used by this client\npublic void setService(Service service) {\n    if (service == null) {\n        throw new InvalidParameterException(\"service must not be null\");\n    }\n    this.service = service;\n}\n\n// Set the other service to be used by this client\npublic void setOtherService(Service otherService) {\n    if (otherService == null) {\n        throw new InvalidParameterException(\"otherService must not be null\");\n    }\n    this.otherService = otherService;\n}\n</source>\nBecause these injections happen independently there is no way to tell when the injector is finished wiring the client. A dependency can be left null simply by the injector failing to call its setter. This forces the check that injection was completed from when the client is assembled to whenever it is used.\n\n<source lang=\"java\">\n// Set the service to be used by this client\npublic void setService(Service service) {\n    this.service = service;\n}\n\n// Set the other service to be used by this client\npublic void setOtherService(Service otherService) {\n    this.otherService = otherService;\n}\n\n// Check the service references of this client\nprivate void validateState() {\n    if (service == null) {\n        throw new IllegalStateException(\"service must not be null\");\n    }\n    if (otherService == null) {\n        throw new IllegalStateException(\"otherService must not be null\");\n    }\n}\n\n// Method that uses the service references\npublic void doSomething() {\n    validateState();\n    service.doYourThing();\n    otherService.doYourThing();\n}\n</source>\n\n==== Interface injection comparison ====\nThe advantage of interface injection is that dependencies can be completely ignorant of their clients yet can still receive a reference to a new client and, using it, send a reference-to-self back to the client. In this way, the dependencies become injectors. The key is that the injecting method (which could just be a classic setter method) is provided through an interface.\n\nAn assembler is still needed to introduce the client and its dependencies. The assembler would take a reference to the client, cast it to the setter interface that sets that dependency, and pass it to that dependency object which would turn around and pass a reference-to-self back to the client.\n\nFor interface injection to have value, the dependency must do something in addition to simply passing back a reference to itself. This could be acting as a factory or sub-assembler to resolve other dependencies, thus abstracting some details from the main assembler. It could be reference-counting so that the dependency knows how many clients are using it. If the dependency maintains a collection of clients, it could later inject them all with a different instance of itself.\n<source lang=\"java\">\n// Service setter interface.\npublic interface ServiceSetter {\n    public void setService(Service service);\n}\n\n// Client class\npublic class Client implements ServiceSetter {\n    // Internal reference to the service used by this client.\n    private Service service;\n\n    // Set the service that this client is to use.\n    @Override\n    public void setService(Service service) {\n        this.service = service;\n    }\n}\n\n// Injector class\npublic class ServiceInjector {\n\tSet<ServiceSetter> clients;\n\tpublic void inject(ServiceSetter client) {\n\t\tclients.add(client);\n\t\tclient.setService(new ServiceFoo());\n\t}\n\tpublic void switchToBar() {\n\t\tfor (Client client : clients) {\n\t\t\tclient.setService(new ServiceBar());\n\t\t}\n\t}\n}\n\n// Service classes\npublic class ServiceFoo implements Service {}\npublic class ServiceBar implements Service {}\n</source>\n\n=== Assembling examples ===\nManually assembling in main by hand is one way of implementing dependency injection.\n\n<source lang=\"java\">\npublic class Injector {\n    public static void main(String[] args) {\n        // Build the dependencies first\n        Service service = new ExampleService();\n\n        // Inject the service, constructor style\n        Client client = new Client(service);\n\n        // Use the objects\n        System.out.println(client.greet());\n    }\t\n}\n</source>\nThe example above constructs the object graph manually and then invokes it at one point to start it working. Important to note is that this injector is not pure. It uses one of the objects it constructs. It has a purely construction-only relationship with ExampleService but mixes construction and using of Client. This should not be common. It is, however, unavoidable. Just like object oriented software needs a non-object oriented static method like main() to get started, a dependency injected object graph needs at least one (preferably only one) entry point to get the whole thing started.\n\nManual construction in the main method may not be this straight forward and may involve calling [[Builder pattern|builders]], [[Factory (object-oriented programming)|factories]], or other [[Creational pattern|construction patterns]] as well. This can be fairly advanced and abstract. The line is crossed from manual dependency injection to [[Software framework|framework]] dependency injection once the constructing code is no longer custom to the application and is instead universal.<ref>{{citation|url=http://www.riehle.org/computer-science/research/dissertation/diss-a4.pdf|first=Dirk|last=Riehle|title=Framework Design: A Role Modeling Approach|publisher=[[ETH Zurich|Swiss Federal Institute of Technology]]|year=2000|postscript=<!--none-->}}</ref>\n\nFrameworks like [[Spring Framework|Spring]] can construct these same objects and wire them together before returning a reference to client. All mention of the concrete ExampleService can be moved from the code to the configuration data.\n\n<source lang=\"java\">\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Injector {\n\tpublic static void main(String[] args) {\n\t\t// -- Assembling objects -- //\n\t\tBeanFactory beanfactory = new ClassPathXmlApplicationContext(\"Beans.xml\");\n\t\tClient client = (Client) beanfactory.getBean(\"client\");\n\n\t\t// -- Using objects -- //\n\t\tSystem.out.println(client.greet());\n\t}\n}\n</source>\n\nFrameworks like Spring allow assembly details to be externalized in configuration files.\nThis code (above) constructs objects and wires them together according to Beans.xml (below). ExampleService is still constructed even though it is only mentioned below. A long and complex object graph can be defined this way and the only class mentioned in code would be the one with the entry point method, which in this case is greet().\n\n<source lang=\"xml\">\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n    <bean id=\"service\" class=\"ExampleService\">\n    </bean>\n\n    <bean id=\"client\" class=\"Client\">\n        <constructor-arg value=\"service\" />        \n    </bean>\n</beans>\n</source>\n\nIn the example above Client and Service have not had to undergo any changes to be provided by spring. They are allowed to remain simple [[Plain Old Java Object|POJO]]s.<ref>{{Cite web|title = Spring Tips: A POJO with annotations is not Plain|url = http://springtips.blogspot.com/2007/07/pojo-with-annotations-is-not-plain.html|accessdate = 2015-07-18|archive-url = https://web.archive.org/web/20150715045353/http://springtips.blogspot.com/2007/07/pojo-with-annotations-is-not-plain.html|archive-date = 2015-07-15|url-status = dead}}</ref><ref>{{Cite web|title = Annotations in POJO \u2013 a boon or a curse? {{!}} Techtracer|url = http://techtracer.com/2007/04/07/annotations-in-pojo-a-boon-or-a-curse/|accessdate = 2015-07-18|date = 2007-04-07}}</ref><ref>\n{{cite book\n|url=https://books.google.com/?id=FCVnsq1ZUI0C&pg=PA64&lpg=PA64&dq=spring+pojo+annotation+free#v=onepage&q=spring%20pojo%20annotation%20free&f=false|title=Pro Spring Dynamic Modules for OSGi Service Platforms|publisher=APress |accessdate=2015-07-06|isbn=9781430216124|date=2009-02-17}}\n</ref> This shows how spring can connect services and clients that are completely ignorant of its existence. This could not be said if spring annotations are added to the classes. By keeping spring specific annotations and calls from spreading out among many classes, the system stays only loosely dependent on spring.<ref name=\"sites.google.com\"/> This can be important if the system intends to outlive spring.\n\nThe choice to keep POJOs pure does not come without cost. Rather than spending the effort to develop and maintain complex configuration files it is possible to simply use annotations to mark classes and let spring do the rest of the work. Resolving dependencies can be simple if they follow a convention such as matching by type or by name. This is choosing [[convention over configuration]].<ref>{{Cite web|title = Captain Debug's Blog: Is 'Convention Over Configuration' Going Too Far?|url = http://www.captaindebug.com/2011/08/is-convention-over-configuration-going.html#.VapTMvlVhHx|website = www.captaindebug.com|accessdate = 2015-07-18}}</ref> It is also arguable that, when refactoring to another framework, removing framework specific annotations would be a trivial part of the task<ref>{{Cite web|title = What's the issue with @Inject? {{!}} Colin's Devlog|url = http://blog.cgdecker.com/2010/01/whats-issue-with-inject.html|website = blog.cgdecker.com|accessdate = 2015-07-18|first = Colin|last = Decker}}</ref> and many injection annotations are now standardized.<ref>{{Cite web|title = Dagger - A new Java dependency injection framework|url = http://musingsofaprogrammingaddict.blogspot.com/2012/11/dagger-new-java-dependency-injection.html|website = Dagger - A new Java dependency injection framework - Musings of a Programming Addict|date = 2012-11-18|accessdate = 2015-07-18|first = Gunnar|last = Morling}}</ref><ref>{{Cite web|title = The Java Community Process(SM) Program - JSRs: Java Specification Requests - detail JSR# 330|url = https://www.jcp.org/en/jsr/detail?id=330|website = www.jcp.org|accessdate = 2015-07-18}}</ref>\n\n<source lang=\"java\">\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class Injector {\n\tpublic static void main(String[] args) {\n\t\t// Assemble the objects\n\t\tBeanFactory beanfactory = new AnnotationConfigApplicationContext(MyConfiguration.class);\n\t\tClient client = beanfactory.getBean(Client.class);\n\n\t\t// Use the objects\n\t\tSystem.out.println(client.greet());\n\t}\n}\n</source>\n\n<source lang=\"java\">\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@ComponentScan\npublic class MyConfiguration {\n    @Bean\n    public Client client(ExampleService service) {\n        return new Client(service);\n    }\n}\n</source>\n\n<source lang=\"java\">\n@Component\npublic class ExampleService {\n    public String getName() {\n        return \"World!\";\n    }\n}\n</source>\n\n=== Assembly comparison ===\nThe different injector implementations (factories, [[Service locator pattern|service locator]]s, and dependency injection containers) are not that different as far as dependency injection is concerned. What makes all the difference is where they are allowed to be used. Move calls to a factory or a service locator out of the client and into main and suddenly main makes a fairly good dependency injection container.\n\nBy moving all knowledge of the injector out, a clean client, free of knowledge of the outside world, is left behind. However, any object that uses other objects can be considered a client. The object that contains main is no exception. This main object is not using dependency injection. It is actually using the service locator pattern. This can not be avoided because the choice of service implementations must be made somewhere.\n\nExternalizing the dependencies into configuration files does not change this fact. What makes this reality part of a good design is that the service locator is not spread throughout the code base. It is confined to one place per application. This leaves the rest of the code base free to use dependency injection to make clean clients.\n\n=== Dependency Injection Pattern ===\n\nThe examples until now have been overly simple examples about constructing a string. However, the dependency injection pattern is most useful when constructing an object graph where objects communicate via messages. Objects constructed in main will last for the life of the program. The typical pattern is to construct the graph and then call one method on one object to send the flow of control into the object graph. Just as main is the entry point to the static code, this one method is the entry point to the applications non-static code.\n\n<source lang=\"java\">\npublic static void main(String[] args) throws IOException {\n\n    // Construction code. \n    Greeter greeter = new Greeter(System.out); // This may be many lines that connect many objects\n    \n    // Behavior code.\n    greeter.greet(); // This is one call to one method on one object in the object graph\n}\n\nclass Greeter {\n    public void greet() {\n        this.out.println(\"Hello world!\");\n    }\n    public Greeter(PrintStream out) {\n        this.out = out;\n    }\n    private PrintStream out;\n}\n\n</source>\n\n===AngularJS example===\nIn the [[AngularJS]] framework, there are only three ways a component (object or function) can directly access its dependencies:\n\n# The component can create the dependency, typically using the <code>new</code> operator.\n# The component can look up the dependency, by referring to a global variable.\n# The component can have the dependency passed to it where it is needed.\nThe first two options of creating or looking up dependencies are not optimal because they hard code the dependency to the component. This makes it difficult, if not impossible, to modify the dependencies. This is especially problematic in tests, where it is often desirable to provide mock dependencies for test isolation.\n\nThe third option is the most viable, since it removes the responsibility of locating the dependency from the component. The dependency is simply handed to the component.\n\n<source lang=\"JavaScript\">\nfunction SomeClass(greeter) {\n  this.greeter = greeter;\n}\n\nSomeClass.prototype.doSomething = function(name) {\n  this.greeter.greet(name);\n}\n</source>\n\nIn the above example <code>SomeClass</code> is not concerned with creating or locating the greeter dependency, it is simply handed the greeter when it is instantiated.\n\nThis is desirable, but it puts the responsibility of getting hold of the dependency on the code that constructs <code>SomeClass</code>.\n\nTo manage the responsibility of dependency creation, each AngularJS application has an injector. The injector is a service locator that is responsible for construction and look-up of dependencies.\n\nHere is an example of using the injector service:\n\n<source lang=\"JavaScript\">\n// Provide the wiring information in a module\nvar myModule = angular.module('myModule', []);\n\n// Teach the injector how to build a greeter service. \n// greeter is dependent on the $window service. \n// The greeter service is an object that\n// contains a greet method.\nmyModule.factory('greeter', function($window) {\n  return {\n    greet: function(text) {\n      $window.alert(text);\n    }\n  };\n});\n</source>\n\nCreate a new injector that can provide components defined in the <code>myModule</code> module and request our greeter service from the injector. (This is usually done automatically by the AngularJS bootstrap).\n\n<source lang=\"JavaScript\">\nvar injector = angular.injector(['myModule', 'ng']);\nvar greeter = injector.get('greeter');\n</source>\n\nAsking for dependencies solves the issue of hard coding, but it also means that the injector needs to be passed throughout the application. Passing the injector breaks the [[Law of Demeter]]. To remedy this, we use a declarative notation in our HTML templates, to hand the responsibility of creating components over to the injector, as in this example:\n\n<source lang=\"html\">\n<div ng-controller=\"MyController\">\n  <button ng-click=\"sayHello()\">Hello</button>\n</div>\n</source>\n<source lang=\"JavaScript\">\nfunction MyController($scope, greeter) {\n  $scope.sayHello = function() {\n    greeter.greet('Hello World');\n  };\n}\n</source>\nWhen AngularJS compiles the HTML, it processes the <code>ng-controller</code> directive, which in turn asks the injector to create an instance of the controller and its dependencies.\n\n injector.instantiate(MyController);\nThis is all done behind the scenes. Because the <code>ng-controller</code> defers to the injector to instantiate the class, it can satisfy all of the dependencies of <code>MyController</code> without the controller ever knowing about the injector. The application code simply declares the dependencies it needs, without having to deal with the injector. This setup does not break the [[Law of Demeter]].\n\n==See also==\n* [[Architecture description language]]\n* [[Factory pattern]]\n* [[Inversion of control]]\n* [[Plug-in (computing)]]\n* [[Strategy pattern]]\n* [[AngularJS]]\n* [[Service locator pattern]]\n* [[Parameter (computer programming)]]\n* [[Quaject]]\n\n==References==\n{{Reflist}}\n\n==External links==\n{{Commons category|Dependency injection}}\n* [http://blog.ploeh.dk/2011/07/28/CompositionRoot/ Composition Root by Mark Seemann]\n* [http://www.theserverside.com/tt/articles/article.tss?l=IOCBeginners A beginners guide to Dependency Injection]\n* [http://www.ddj.com/185300375 Dependency Injection & Testable Objects: Designing loosely coupled and testable objects] - Jeremy Weiskotten; [[Dr. Dobb's Journal]], May 2006.\n* [http://www.griffincaprio.com/blog/2018/04/design-patterns-dependency-injection.html Design Patterns: Dependency Injection -- MSDN Magazine, September 2005]\n* [http://martinfowler.com/articles/injection.html Martin Fowler's original article that introduced the term Dependency Injection]\n* [http://martinfowler.com/eaaCatalog/plugin.html P of EAA: Plugin]\n* [http://www.javalobby.org/articles/di-heritage/ The Rich Engineering Heritage Behind Dependency Injection] - [[Andrew McVeigh]] - A detailed history of dependency injection.\n* [http://tutorials.jenkov.com/dependency-injection/index.html What is Dependency Injection?] - An alternative explanation - Jakob Jenkov\n* [http://www.developer.com/net/net/article.php/3636501 Writing More Testable Code with Dependency Injection -- Developer.com, October 2006]\n* [http://msdn.microsoft.com/en-us/library/dd460648.aspx Managed Extensibility Framework Overview -- MSDN]\n* [https://web.archive.org/web/20120425150101/http://www.midmarsh.co.uk/planetjava/tutorials/language/WatchingtheObservables.PDF Old fashioned description of the Dependency Mechanism by Hunt 1998] \n* [http://blog.thecodewhisperer.com/2011/12/07/refactor-your-way-to-a-dependency-injection-container/ Refactor Your Way to a Dependency Injection Container]\n* [http://php-di.org/doc/understanding-di.html Understanding DI in PHP]\n* [https://medium.com/@wrong.about/you-dont-need-a-dependency-injection-container-10a5d4a5f878 You Don't Need a Dependency Injection Container]\n{{Design Patterns patterns}}\n\n<!-- Interwikies -->\n\n{{DEFAULTSORT:Dependency Injection}}\n[[Category:Component-based software engineering]]\n[[Category:Software architecture]]\n[[Category:Software design patterns]]\n[[Category:Articles with example Java code]]\n", "name_user": "Buchskj", "label": "safe", "comment": "swapped a word that was not correct", "url_page": "//en.wikipedia.org/wiki/Dependency_injection"}
