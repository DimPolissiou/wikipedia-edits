{"title_page": "Shunri", "text_new": "{{moreref|date=December 2017}}\n\n{{Infobox caste\n| caste_name          = Sunri (Excluding Saha) <br/>\u09b6\u09c1\u0981\u09a1\u09bc\u09bf (\u09b8\u09be\u09b9\u09be \u09ac\u09cd\u09af\u09be\u09a4\u09c0\u09a4)\n| classification      =Sub-Caste <br/>\u0989\u09aa\u099c\u09be\u09a4\u09bf \n| family_names        = Layek, Saha, Sabui, Chel, Mai, Bishui, Biswas, Midya,khan,Mandal(Mondal),Mallick,paramanik\n\n\n| population          = 317,543 (West Bengal, 2001 census)\n| populated_states    = [[West Bengal]]\n| languages           = [[Bengali language|Bengali]]\n| religions           = [[Hinduism]]\n| kula_devi           = [[Lakshmi]]\n|Scheduled Caste=Scheduled Caste <br/>\u09a4\u09aa\u09b6\u09bf\u09b2\u09c0 \u099c\u09be\u09a4\u09bf|country=India|state=West Bengal|education_reservation=|employment_reservation=}}\n\n'''Sunri (Excluding Saha)''' ({{lang-bn|\u09b6\u09c1\u0981\u09a1\u09bc\u09bf (\u09b8\u09be\u09b9\u09be \u09ac\u09cd\u09af\u09be\u09a4\u09c0\u09a4)}}) are a [[Bengali Hindu]] Sub-Caste whose traditional occupation is the distillation and selling of country wine..<ref name=\"kundu\">{{cite book |title=Bangali Hindu Jati Parichay |trans-title=An Introduction of Bengali Hindu Castes |language=Bengali |last=Kundu |first=Santosh Kumar |year=2008 |publisher=Presidency Library |location=Kolkata |isbn=978-81-89466-13-8 |pages=264\u2013265}}</ref>\n\n== History ==\nIn the census of 2001, the Sunri (Excluding Saha) numbered 317,543 in West Bengal, consisting of 1.7% of the total Scheduled caste population of the state.<ref name=\"goi\">{{cite web |url=http://censusindia.gov.in/Tables_Published/SCST/dh_sc_westbengal.pdf |title=West Bengal - Data Highlights: The Scheduled Castes - Census of India 2001 |work=Census of India |publisher=Government of India |accessdate=December 10, 2011}}</ref> Sunri (excluding Saha) are scheduled castes in West Bengal.\n\n== Ethnology ==\nThe Sunri (Excluding Saha) are divided into four regional subgroups namely Rarhi, Barendri, Bangiya and Maghi. They have the following gotras - Bharadwaj, Kashyap, Mojrishi, Markandarishi, Gargarishi, Nagarishi, Anandarishi, Madhurishi, Sandilya and Banarishi.{{cn|date=April 2017}}\n\n== Religion ==\nThe Shunris are predominantly Vaishnavas. [[Lakshmi]] is their titular deity. Thursday being the weekly day of worship of Lakshmi, they keep used to keep their liquor shops closed. Even today, both the foreign and country liquor off and on shops remain closed on Thursday. On the first day of Magh, they worship Bair Lakshmi with much pomp and grandeur. In the month of Kartik, they worship Kartik. The Shunris keep pigeons as pets, because they believe the flapping of their wings bring good luck to them.{{cn|date=April 2017}}\n\n== References ==\n{{Reflist}}\n\n{{Bengali Hindu people}}\n{{Scheduled Castes in West Bengal}}\n\n[[Category:Bengali Hindu castes]]\n[[Category:Social groups of West Bengal]]\n", "text_old": "{{moreref|date=December 2017}}\n\n{{Infobox caste\n| caste_name          = Sunri (Excluding Saha) <br/>\u09b6\u09c1\u0981\u09a1\u09bc\u09bf (\u09b8\u09be\u09b9\u09be \u09ac\u09cd\u09af\u09be\u09a4\u09c0\u09a4)\n| classification      =Sub-Caste <br/>\u0989\u09aa\u099c\u09be\u09a4\u09bf \n| family_names        = Layek, Saha, Sabui, Chel, Mai, Bishui, Biswas, Midya,khan,Mandal(Mondal),Mallick,paramanik\n\n\n| population          = 317,543 (West Bengal, 2001 census)\n| populated_states    = [[West Bengal]]\n| languages           = [[Bengali language|Bengali]]\n| religions           = [[Hinduism]]\n| kula_devi           = [[Lakshmi]]\n|Scheduled Caste=Scheduled Caste <br/>\u09a4\u09aa\u09b6\u09bf\u09b2\u09c0 \u099c\u09be\u09a4\u09bf|country=India|state=West Bengal|education_reservation=|employment_reservation=}}\n\n'''Sunri (Excluding Saha)''' ({{lang-bn|\u09b6\u09c1\u0981\u09a1\u09bc\u09bf (\u09b8\u09be\u09b9\u09be \u09ac\u09cd\u09af\u09be\u09a4\u09c0\u09a4)}}) are a [[Bengali Hindu]] Sub-Caste whose traditional occupation is the distillation and selling of country wine..<ref name=\"kundu\">{{cite book |title=Bangali Hindu Jati Parichay |trans-title=An Introduction of Bengali Hindu Castes |language=Bengali |last=Kundu |first=Santosh Kumar |year=2008 |publisher=Presidency Library |location=Kolkata |isbn=978-81-89466-13-8 |pages=264\u2013265}}</ref>\n\n== History ==\nIn the census of 2001, the Sunri (Excluding Saha) numbered 317,543 in West Bengal, consisting of 1.7% of the total Scheduled caste population of the state.<ref name=\"goi\">{{cite web |url=http://censusindia.gov.in/Tables_Published/SCST/dh_sc_westbengal.pdf |title=West Bengal - Data Highlights: The Scheduled Castes - Census of India 2001 |work=Census of India |publisher=Government of India |accessdate=December 10, 2011}}</ref> Sunri (excluding Saha) are scheduled castes in West Bengal.\n\n== Ethnology ==\nThe Shunris are divided into four regional subgroups namely Rarhi, Barendri, Bangiya and Maghi. They have the following gotras - Bharadwaj, Kashyap, Mojrishi, Markandarishi, Gargarishi, Nagarishi, Anandarishi, Sandilya and Banarishi.{{cn|date=April 2017}}\n\n== Religion ==\nThe Shunris are predominantly Vaishnavas. [[Lakshmi]] is their titular deity. Thursday being the weekly day of worship of Lakshmi, they keep used to keep their liquor shops closed. Even today, both the foreign and country liquor off and on shops remain closed on Thursday. On the first day of Magh, they worship Bair Lakshmi with much pomp and grandeur. In the month of Kartik, they worship Kartik. The Shunris keep pigeons as pets, because they believe the flapping of their wings bring good luck to them.{{cn|date=April 2017}}\n\n== References ==\n{{Reflist}}\n\n{{Bengali Hindu people}}\n{{Scheduled Castes in West Bengal}}\n\n[[Category:Bengali Hindu castes]]\n[[Category:Social groups of West Bengal]]\n", "name_user": "Madhusudanthehoneydemonkiller", "label": "safe", "comment": "", "url_page": "//en.wikipedia.org/wiki/Shunri"}
{"title_page": "Remote procedure call", "text_new": "{{Expand German|Remote Procedure Call|date=April 2020}}\n{{short description|Mechanism to allow software to execute a remote procedure}}\nIn [[Distributed computing|distributed computing]], a '''remote procedure call''' ('''RPC''') is when a computer program causes a procedure (subroutine) to execute in a different address space (commonly on another computer on a shared network), which is coded as if it were a normal (local) procedure call, without the programmer explicitly coding the details for the remote interaction. That is, the programmer writes essentially the same code whether the subroutine is local to the executing program, or remote. This is a form of client\u2013server interaction (caller is client, executor is server), typically implemented via a request\u2013response message-passing system. In the object-oriented programming paradigm, RPC calls are represented by remote method invocation (RMI). The RPC model implies a level of location transparency, namely that calling procedures are largely the same whether they are local or remote, but usually they are not identical, so local calls can be distinguished from remote calls. Remote calls are usually orders of magnitude slower and less reliable than local calls, so distinguishing them is important.\n\nRPCs are a form of inter-process communication (IPC), in that different processes have different address spaces: if on the same host machine, they have distinct virtual address spaces, even though the physical address space is the same; while if they are on different hosts, the physical address space is different. Many different (often incompatible) technologies have been used to implement the concept.\n\n==History and origins==\nRequest\u2013response protocols date to early distributed computing in the late 1960s, theoretical proposals of remote procedure calls as the model of network operations date to the 1970s, and practical implementations date to the early 1980s.  [[Bruce Jay Nelson]] is generally credited with coining the term \"remote procedure call\" in 1981.<ref>{{cite book |author= Bruce Jay Nelson |title= Remote Procedure Call |work= PARC CSL-81-9 (Also CMU-CS-81-119) |publisher= Xerox Palo Alto Research Center |date= May 1981 |author-link= Bruce Jay Nelson }} PhD thesis.</ref>\n\nRemote procedure calls used in modern operating systems trace their roots back to the [[RC 4000 Multiprogramming System|RC 4000 multiprogramming system]],<ref>{{Cite web|title = Per Brinch Hansen \u2022 IEEE Computer Society|url = http://www.computer.org/web/awards/pioneer-per-hansen|website = www.computer.org|accessdate = 2015-12-15}}</ref> which used a request-response communication protocol for process synchronization.<ref>{{Cite book|title = RC 4000 Computer Software: Multiprogramming System|last = Brinch Hansen|first = Per|publisher = Regnecentralen|year = 1969|isbn = |location = Copenhagen, Denmark|pages = |url = http://brinch-hansen.net/papers/1969c.pdf}}</ref> The idea of treating network operations as remote procedure calls goes back at least to the 1970s in early [[ARPANET]] documents.<ref>{{cite web |title= A High-Level Framework for Network-Based Resource Sharing |author= James E. White |date= December 23, 1975 |publisher= [[Augmentation Research Center]] |work= RFC 707  |url= http://tools.ietf.org/html/rfc707 |accessdate= July 11, 2011 }}</ref> In 1978, [[Per Brinch Hansen]] proposed Distributed Processes, a language for distributed computing based on \"external requests\" consisting of procedure calls between processes.<ref>{{Cite journal|url = http://brinch-hansen.net/papers/1978a.pdf|title = Distributed processes: a concurrent programming concept|last = Brinch Hansen|first = Per|date = November 1978|journal = Communications of the ACM|volume = 21|issue = 11|pages = 934\u2013941|doi = 10.1145/359642.359651|pmid = |access-date = |citeseerx = 10.1.1.107.3108}}</ref>\n\nOne of the earliest practical implementations was in 1982 by [[Brian Randell]] and colleagues for their [[Newcastle Connection]] between UNIX machines.<ref name=\"Newcastle_1982\">{{cite journal |title=The Newcastle Connection |author-last1=Brownbridge |author-first1=David R. |author-last2=Marshall |author-first2=Lindsay F. |author-last3=Randell |author-first3=Brian |author-link3=Brian Randell |journal=Software \u2013 Practice and Experience |volume=12 |issue=12 |year=1982 |doi=10.1002/spe.4380121206 |pages=1147\u20131162 |url=http://www.cs.ncl.ac.uk/publications/articles/papers/399.pdf |access-date=2016-08-16 |url-status=dead |archive-url=https://web.archive.org/web/20160816184205/http://www.cs.ncl.ac.uk/research/pubs/articles/papers/399.pdf |archive-date=2016-08-16 }}</ref>  This was soon followed by \"Lupine\" by Andrew Birrell and Bruce Nelson in the [[Cedar (programming environment)|Cedar]] environment at [[Xerox PARC]].<ref>{{cite journal|doi=10.1145/2080.357392|year = 1984|title = Implementing remote procedure calls|journal = ACM Transactions on Computer Systems|volume = 2|pages = 39\u201359|last1 = Birrell|first1 = Andrew D.|last2 = Nelson|first2 = Bruce Jay|url = https://www.cs.cmu.edu/~dga/15-712/F07/papers/birrell842.pdf}}</ref><ref name=\"award1994\">{{cite web |title= 1994 \u2013 Andrew Birrell, Bruce Nelson: Remote Procedure Call |publisher= [[Association for Computing Machinery]] |work= Software System Award citation |url= http://awards.acm.org/citation.cfm?id=5125494&srt=all&aw=149&ao=SOFTWSYS&yr=1994 |accessdate= July 11, 2011 |url-status= dead |archiveurl= https://web.archive.org/web/20120402204704/http://awards.acm.org/citation.cfm?id=5125494&srt=all&aw=149&ao=SOFTWSYS&yr=1994 |archivedate= April 2, 2012 }}</ref><ref>{{cite web |title= SIGOPS Hall of Fame Award |publisher= [[Association for Computing Machinery]] |work= Special Interest Group on Operating Systems |url= http://www.sigops.org/award-hof.html |accessdate= July 11, 2011 }}</ref> Lupine automatically generated stubs, providing type-safe bindings, and used an efficient protocol for communication.<ref name=\"award1994\"/> One of the first business uses of RPC was by [[Xerox]] under the name \"Courier\" in 1981. The first popular implementation of RPC on [[Unix]] was [[Open Network Computing Remote Procedure Call|Sun's RPC]] (now called ONC RPC), used as the basis for Network File System (NFS).\n\nIn the 1990s, with the popularity of [[object-oriented programming]], an alternative model of remote method invocation (RMI) was widely implemented, such as in Common Object Request Broker Architecture (CORBA, 1991) and [[Java remote method invocation]]. RMIs in turn fell in popularity with the rise of the internet, particularly in the 2000s.\n\n==Message passing==\nRPC is a [[request\u2013response]] protocol. An RPC is initiated by the ''client'', which sends a request message to a known remote ''server'' to execute a specified procedure with supplied parameters. The remote server sends a response to the client, and the application continues its process. While the server is processing the call, the client is blocked (it waits until the server has finished processing before resuming execution), unless the client sends an asynchronous request to the server, such as an [[XMLHttpRequest]]. There are many variations and subtleties in various implementations, resulting in a variety of different (incompatible) RPC protocols.\n\nAn important difference between remote procedure calls and local calls is that remote calls can fail because of unpredictable network problems. Also, callers generally must deal with such failures without knowing whether the remote procedure was actually invoked. [[Idempotent]] procedures (those that have no additional effects if called more than once) are easily handled, but enough difficulties remain that code to call remote procedures is often confined to carefully written low-level subsystems.\n\n===Sequence of events===\n# The client calls the client [[Stub (distributed computing)|stub]]. The call is a local procedure call, with parameters pushed on to the stack in the normal way.\n# The [[Class stub|client stub]] packs the parameters into a message and makes a system call to send the message. Packing the parameters is called [[marshalling (computer science)|marshalling]].\n# The client's local [[operating system]] sends the message from the client machine to the server machine.\n# The local [[operating system]] on the server machine passes the incoming packets to the [[Class skeleton|server stub]].\n# The server stub unpacks the parameters from the message. Unpacking the parameters is called [[unmarshalling]].\n# Finally, the server stub calls the server procedure. The reply traces the same steps in the reverse direction.\n\n==Standard contact mechanisms==\nTo let different clients access servers, a number of standardized RPC systems have been created. Most of these use an [[interface description language]] (IDL) to let various platforms call the RPC. The IDL files can then be used to generate code to interface between the client and servers.\n\n==Analogues==\n{{refimprove section|date=December 2013}}\nNotable RPC implementations and analogues include:\n\n===Language-specific===\n* [[Java (programming language)|Java]]'s [[Java Remote Method Invocation]] (Java RMI) API provides similar functionality to standard Unix RPC methods.\n*[https://golang.org/ Go] provides [https://golang.org/pkg/net/rpc/ package rpc] for implementing RPC, with support for asynchronous calls.\n*[[Modula-3]]'s network objects, which were the basis for Java's RMI<ref>[http://www.computerworld.com.au/index.php/id;1422447371;pp;3;fp;4194304;fpid;1 The A-Z of Programming Languages: Modula-3 - a-z of programming languages] {{webarchive|url=https://web.archive.org/web/20090105145818/http://www.computerworld.com.au/index.php/id%3B1422447371%3Bpp%3B3%3Bfp%3B4194304%3Bfpid%3B1 |date=2009-01-05 }}. Computerworld. Retrieved on 2013-07-17.</ref>\n* [[RPyC]] implements RPC mechanisms in Python, with support for asynchronous calls.\n* [[Distributed Ruby]] (DRb) allows Ruby programs to communicate with each other on the same machine or over a network. DRb uses remote method invocation (RMI) to pass commands and data between processes.\n* [[Erlang (programming language)|Erlang]] is process oriented and natively supports distribution and RPCs via message passing between nodes and local processes alike.\n* [[Elixir (programming language)|Elixir]] builds on top of the Erlang VM and allows process communication (Elixir/Erlang processes, not OS processes) of the same network out-of-the-box via Agents and message passing.\n\n===Application-specific===\n* [[Action Message Format]] (AMF) allows [[Adobe Flex]] applications to communicate with [[Front and back ends|back-ends]] or other applications that support AMF.\n* [[Remote Function Call]] is the standard SAP interface for communication between SAP systems. RFC calls a function to be executed in a remote system.\n\n===General===\n* NFS ([[Network File System]]) is one of the most prominent users of RPC\n* [[Open Network Computing Remote Procedure Call]], by [[Sun Microsystems]]\n* [[D-Bus]] open source [[Inter-process communication|IPC]] program provides similar function to [[CORBA]].\n* [[SORCER]] provides the API and exertion-oriented language (EOL) for a federated method invocation\n* [[XML-RPC]] is an RPC protocol that uses [[XML]] to encode its calls and [[HTTP]] as a transport mechanism.\n* [[JSON-RPC]] is an RPC protocol that uses [[JSON]]-encoded messages\n* [[JSON-WSP]] is an RPC protocol that uses [[JSON]]-encoded messages\n* [[SOAP]] is a successor of XML-RPC and also uses XML to encode its HTTP-based calls.\n* [[ZeroC]]'s [[Internet Communications Engine]] (Ice) distributed computing platform.\n* [[Etch (protocol)|Etch]] framework for building network services.\n* [[Apache Thrift]] protocol and framework.\n* [[CORBA]] provides remote procedure invocation through an intermediate layer called the ''object request broker''.\n* [[Libevent]] provides a framework for creating RPC servers and clients.<ref>[http://www.monkey.org/~provos/libevent/doxygen-1.4.10/ libevent: Main Page]. Monkey.org. Retrieved on 2013-07-17.</ref>\n* [[Windows Communication Foundation]] is an application programming interface in the .NET framework for building connected, service-oriented applications.\n* [[.NET Framework|Microsoft .NET]] [[.NET Remoting|Remoting]] offers RPC facilities for distributed systems implemented on the Windows platform. It has been superseded by [[Windows Communication Foundation|WCF]].\n* The Microsoft [[Distributed Component Object Model|DCOM]] uses [[Microsoft RPC|MSRPC]] which is based on [[DCE/RPC]]\n* The Open Software Foundation [[DCE/RPC]] Distributed Computing Environment (also implemented by Microsoft).\n* Google [[Protocol Buffers]] (protobufs) package includes an interface definition language used for its RPC protocols<ref>{{cite web |title= Protocol Buffers - Google's data interchange format |work= Google project website |url= https://code.google.com/p/protobuf/ |accessdate= November 1, 2011 }}</ref> open sourced in 2015 as [[gRPC]].<ref>{{cite web | title = gRPC open-source universal RPC framework | work= Google project website | url=http://www.grpc.io/ | accessdate= September 7, 2016}}</ref>\n* [[Web Application Messaging Protocol|WAMP]] combines RPC and [[Publish\u2013subscribe pattern|Publish-Subscribe]] into a single, transport-agnostic protocol.\n* [[Google Web Toolkit]] uses an asynchronous RPC to communicate to the server service.<ref>{{cite web |title=Google Web Toolkit |work= Google project website |url= https://code.google.com/webtoolkit/ |accessdate= November 1, 2011 }}</ref>\n* [[Apache Avro]] provides RPC where client and server exchange schemas in the connection handshake and code generation is not required.\n* [https://github.com/EmbeddedRPC/erpc Embedded RPC] is lightweight RPC implementation developed by NXP, targeting primary CortexM cores\n* [http://www.e-s-r.net/specifications/index.html KF Trusted Execution Environment] uses proxy and objects marshaling to communicate objects across sandboxes\n\n==See also==\n* [[9P (protocol)|9P]]\n* [[Microsoft RPC]]\n* [[Local Procedure Call]]\n* [[HTTP]]\n* [[ODBC]]\n* [[Remote evaluation]]\n* [[External Data Representation]]\n* [[Resource-oriented architecture]]\n* [[Distributed object middleware]]\n* [[Fragmented object]]\n* [[gRPC]]\n\n==References==\n{{reflist}}\n\n==External links==\n*RFC 1057 - Specifies version 1 of ONC RPC\n*RFC 5531 - Specifies version 2 of ONC RPC\n*[http://www.cs.cf.ac.uk/Dave/C/node33.html Remote Procedure Calls (RPC)] &mdash; A tutorial on ONC RPC by Dr Dave Marshall of Cardiff University\n*[https://web.archive.org/web/20030404113118/http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&db=bks&srch=&fname=/SGI_Developer/IRIX_NetPG/sgi_html/ch04.html Introduction to RPC Programming] &mdash; A developer's introduction to RPC and XDR, from SGI IRIX documentation.\n\n[[Category:Inter-process communication]]\n[[Category:Middleware]]\n[[Category:Remote procedure call| ]]\n[[Category:Distributed computing]]\n", "text_old": "{{Expand German|German article title|date=April 2020}}\n{{short description|Mechanism to allow software to execute a remote procedure}}\nIn [[Distributed computing|distributed computing]], a '''remote procedure call''' ('''RPC''') is when a computer program causes a procedure (subroutine) to execute in a different address space (commonly on another computer on a shared network), which is coded as if it were a normal (local) procedure call, without the programmer explicitly coding the details for the remote interaction. That is, the programmer writes essentially the same code whether the subroutine is local to the executing program, or remote. This is a form of client\u2013server interaction (caller is client, executor is server), typically implemented via a request\u2013response message-passing system. In the object-oriented programming paradigm, RPC calls are represented by remote method invocation (RMI). The RPC model implies a level of location transparency, namely that calling procedures are largely the same whether they are local or remote, but usually they are not identical, so local calls can be distinguished from remote calls. Remote calls are usually orders of magnitude slower and less reliable than local calls, so distinguishing them is important.\n\nRPCs are a form of inter-process communication (IPC), in that different processes have different address spaces: if on the same host machine, they have distinct virtual address spaces, even though the physical address space is the same; while if they are on different hosts, the physical address space is different. Many different (often incompatible) technologies have been used to implement the concept.\n\n==History and origins==\nRequest\u2013response protocols date to early distributed computing in the late 1960s, theoretical proposals of remote procedure calls as the model of network operations date to the 1970s, and practical implementations date to the early 1980s.  [[Bruce Jay Nelson]] is generally credited with coining the term \"remote procedure call\" in 1981.<ref>{{cite book |author= Bruce Jay Nelson |title= Remote Procedure Call |work= PARC CSL-81-9 (Also CMU-CS-81-119) |publisher= Xerox Palo Alto Research Center |date= May 1981 |author-link= Bruce Jay Nelson }} PhD thesis.</ref>\n\nRemote procedure calls used in modern operating systems trace their roots back to the [[RC 4000 Multiprogramming System|RC 4000 multiprogramming system]],<ref>{{Cite web|title = Per Brinch Hansen \u2022 IEEE Computer Society|url = http://www.computer.org/web/awards/pioneer-per-hansen|website = www.computer.org|accessdate = 2015-12-15}}</ref> which used a request-response communication protocol for process synchronization.<ref>{{Cite book|title = RC 4000 Computer Software: Multiprogramming System|last = Brinch Hansen|first = Per|publisher = Regnecentralen|year = 1969|isbn = |location = Copenhagen, Denmark|pages = |url = http://brinch-hansen.net/papers/1969c.pdf}}</ref> The idea of treating network operations as remote procedure calls goes back at least to the 1970s in early [[ARPANET]] documents.<ref>{{cite web |title= A High-Level Framework for Network-Based Resource Sharing |author= James E. White |date= December 23, 1975 |publisher= [[Augmentation Research Center]] |work= RFC 707  |url= http://tools.ietf.org/html/rfc707 |accessdate= July 11, 2011 }}</ref> In 1978, [[Per Brinch Hansen]] proposed Distributed Processes, a language for distributed computing based on \"external requests\" consisting of procedure calls between processes.<ref>{{Cite journal|url = http://brinch-hansen.net/papers/1978a.pdf|title = Distributed processes: a concurrent programming concept|last = Brinch Hansen|first = Per|date = November 1978|journal = Communications of the ACM|volume = 21|issue = 11|pages = 934\u2013941|doi = 10.1145/359642.359651|pmid = |access-date = |citeseerx = 10.1.1.107.3108}}</ref>\n\nOne of the earliest practical implementations was in 1982 by [[Brian Randell]] and colleagues for their [[Newcastle Connection]] between UNIX machines.<ref name=\"Newcastle_1982\">{{cite journal |title=The Newcastle Connection |author-last1=Brownbridge |author-first1=David R. |author-last2=Marshall |author-first2=Lindsay F. |author-last3=Randell |author-first3=Brian |author-link3=Brian Randell |journal=Software \u2013 Practice and Experience |volume=12 |issue=12 |year=1982 |doi=10.1002/spe.4380121206 |pages=1147\u20131162 |url=http://www.cs.ncl.ac.uk/publications/articles/papers/399.pdf |access-date=2016-08-16 |url-status=dead |archive-url=https://web.archive.org/web/20160816184205/http://www.cs.ncl.ac.uk/research/pubs/articles/papers/399.pdf |archive-date=2016-08-16 }}</ref>  This was soon followed by \"Lupine\" by Andrew Birrell and Bruce Nelson in the [[Cedar (programming environment)|Cedar]] environment at [[Xerox PARC]].<ref>{{cite journal|doi=10.1145/2080.357392|year = 1984|title = Implementing remote procedure calls|journal = ACM Transactions on Computer Systems|volume = 2|pages = 39\u201359|last1 = Birrell|first1 = Andrew D.|last2 = Nelson|first2 = Bruce Jay|url = https://www.cs.cmu.edu/~dga/15-712/F07/papers/birrell842.pdf}}</ref><ref name=\"award1994\">{{cite web |title= 1994 \u2013 Andrew Birrell, Bruce Nelson: Remote Procedure Call |publisher= [[Association for Computing Machinery]] |work= Software System Award citation |url= http://awards.acm.org/citation.cfm?id=5125494&srt=all&aw=149&ao=SOFTWSYS&yr=1994 |accessdate= July 11, 2011 |url-status= dead |archiveurl= https://web.archive.org/web/20120402204704/http://awards.acm.org/citation.cfm?id=5125494&srt=all&aw=149&ao=SOFTWSYS&yr=1994 |archivedate= April 2, 2012 }}</ref><ref>{{cite web |title= SIGOPS Hall of Fame Award |publisher= [[Association for Computing Machinery]] |work= Special Interest Group on Operating Systems |url= http://www.sigops.org/award-hof.html |accessdate= July 11, 2011 }}</ref> Lupine automatically generated stubs, providing type-safe bindings, and used an efficient protocol for communication.<ref name=\"award1994\"/> One of the first business uses of RPC was by [[Xerox]] under the name \"Courier\" in 1981. The first popular implementation of RPC on [[Unix]] was [[Open Network Computing Remote Procedure Call|Sun's RPC]] (now called ONC RPC), used as the basis for Network File System (NFS).\n\nIn the 1990s, with the popularity of [[object-oriented programming]], an alternative model of remote method invocation (RMI) was widely implemented, such as in Common Object Request Broker Architecture (CORBA, 1991) and [[Java remote method invocation]]. RMIs in turn fell in popularity with the rise of the internet, particularly in the 2000s.\n\n==Message passing==\nRPC is a [[request\u2013response]] protocol. An RPC is initiated by the ''client'', which sends a request message to a known remote ''server'' to execute a specified procedure with supplied parameters. The remote server sends a response to the client, and the application continues its process. While the server is processing the call, the client is blocked (it waits until the server has finished processing before resuming execution), unless the client sends an asynchronous request to the server, such as an [[XMLHttpRequest]]. There are many variations and subtleties in various implementations, resulting in a variety of different (incompatible) RPC protocols.\n\nAn important difference between remote procedure calls and local calls is that remote calls can fail because of unpredictable network problems. Also, callers generally must deal with such failures without knowing whether the remote procedure was actually invoked. [[Idempotent]] procedures (those that have no additional effects if called more than once) are easily handled, but enough difficulties remain that code to call remote procedures is often confined to carefully written low-level subsystems.\n\n===Sequence of events===\n# The client calls the client [[Stub (distributed computing)|stub]]. The call is a local procedure call, with parameters pushed on to the stack in the normal way.\n# The [[Class stub|client stub]] packs the parameters into a message and makes a system call to send the message. Packing the parameters is called [[marshalling (computer science)|marshalling]].\n# The client's local [[operating system]] sends the message from the client machine to the server machine.\n# The local [[operating system]] on the server machine passes the incoming packets to the [[Class skeleton|server stub]].\n# The server stub unpacks the parameters from the message. Unpacking the parameters is called [[unmarshalling]].\n# Finally, the server stub calls the server procedure. The reply traces the same steps in the reverse direction.\n\n==Standard contact mechanisms==\nTo let different clients access servers, a number of standardized RPC systems have been created. Most of these use an [[interface description language]] (IDL) to let various platforms call the RPC. The IDL files can then be used to generate code to interface between the client and servers.\n\n==Analogues==\n{{refimprove section|date=December 2013}}\nNotable RPC implementations and analogues include:\n\n===Language-specific===\n* [[Java (programming language)|Java]]'s [[Java Remote Method Invocation]] (Java RMI) API provides similar functionality to standard Unix RPC methods.\n*[https://golang.org/ Go] provides [https://golang.org/pkg/net/rpc/ package rpc] for implementing RPC, with support for asynchronous calls.\n*[[Modula-3]]'s network objects, which were the basis for Java's RMI<ref>[http://www.computerworld.com.au/index.php/id;1422447371;pp;3;fp;4194304;fpid;1 The A-Z of Programming Languages: Modula-3 - a-z of programming languages] {{webarchive|url=https://web.archive.org/web/20090105145818/http://www.computerworld.com.au/index.php/id%3B1422447371%3Bpp%3B3%3Bfp%3B4194304%3Bfpid%3B1 |date=2009-01-05 }}. Computerworld. Retrieved on 2013-07-17.</ref>\n* [[RPyC]] implements RPC mechanisms in Python, with support for asynchronous calls.\n* [[Distributed Ruby]] (DRb) allows Ruby programs to communicate with each other on the same machine or over a network. DRb uses remote method invocation (RMI) to pass commands and data between processes.\n* [[Erlang (programming language)|Erlang]] is process oriented and natively supports distribution and RPCs via message passing between nodes and local processes alike.\n* [[Elixir (programming language)|Elixir]] builds on top of the Erlang VM and allows process communication (Elixir/Erlang processes, not OS processes) of the same network out-of-the-box via Agents and message passing.\n\n===Application-specific===\n* [[Action Message Format]] (AMF) allows [[Adobe Flex]] applications to communicate with [[Front and back ends|back-ends]] or other applications that support AMF.\n* [[Remote Function Call]] is the standard SAP interface for communication between SAP systems. RFC calls a function to be executed in a remote system.\n\n===General===\n* NFS ([[Network File System]]) is one of the most prominent users of RPC\n* [[Open Network Computing Remote Procedure Call]], by [[Sun Microsystems]]\n* [[D-Bus]] open source [[Inter-process communication|IPC]] program provides similar function to [[CORBA]].\n* [[SORCER]] provides the API and exertion-oriented language (EOL) for a federated method invocation\n* [[XML-RPC]] is an RPC protocol that uses [[XML]] to encode its calls and [[HTTP]] as a transport mechanism.\n* [[JSON-RPC]] is an RPC protocol that uses [[JSON]]-encoded messages\n* [[JSON-WSP]] is an RPC protocol that uses [[JSON]]-encoded messages\n* [[SOAP]] is a successor of XML-RPC and also uses XML to encode its HTTP-based calls.\n* [[ZeroC]]'s [[Internet Communications Engine]] (Ice) distributed computing platform.\n* [[Etch (protocol)|Etch]] framework for building network services.\n* [[Apache Thrift]] protocol and framework.\n* [[CORBA]] provides remote procedure invocation through an intermediate layer called the ''object request broker''.\n* [[Libevent]] provides a framework for creating RPC servers and clients.<ref>[http://www.monkey.org/~provos/libevent/doxygen-1.4.10/ libevent: Main Page]. Monkey.org. Retrieved on 2013-07-17.</ref>\n* [[Windows Communication Foundation]] is an application programming interface in the .NET framework for building connected, service-oriented applications.\n* [[.NET Framework|Microsoft .NET]] [[.NET Remoting|Remoting]] offers RPC facilities for distributed systems implemented on the Windows platform. It has been superseded by [[Windows Communication Foundation|WCF]].\n* The Microsoft [[Distributed Component Object Model|DCOM]] uses [[Microsoft RPC|MSRPC]] which is based on [[DCE/RPC]]\n* The Open Software Foundation [[DCE/RPC]] Distributed Computing Environment (also implemented by Microsoft).\n* Google [[Protocol Buffers]] (protobufs) package includes an interface definition language used for its RPC protocols<ref>{{cite web |title= Protocol Buffers - Google's data interchange format |work= Google project website |url= https://code.google.com/p/protobuf/ |accessdate= November 1, 2011 }}</ref> open sourced in 2015 as [[gRPC]].<ref>{{cite web | title = gRPC open-source universal RPC framework | work= Google project website | url=http://www.grpc.io/ | accessdate= September 7, 2016}}</ref>\n* [[Web Application Messaging Protocol|WAMP]] combines RPC and [[Publish\u2013subscribe pattern|Publish-Subscribe]] into a single, transport-agnostic protocol.\n* [[Google Web Toolkit]] uses an asynchronous RPC to communicate to the server service.<ref>{{cite web |title=Google Web Toolkit |work= Google project website |url= https://code.google.com/webtoolkit/ |accessdate= November 1, 2011 }}</ref>\n* [[Apache Avro]] provides RPC where client and server exchange schemas in the connection handshake and code generation is not required.\n* [https://github.com/EmbeddedRPC/erpc Embedded RPC] is lightweight RPC implementation developed by NXP, targeting primary CortexM cores\n* [http://www.e-s-r.net/specifications/index.html KF Trusted Execution Environment] uses proxy and objects marshaling to communicate objects across sandboxes\n\n==See also==\n* [[9P (protocol)|9P]]\n* [[Microsoft RPC]]\n* [[Local Procedure Call]]\n* [[HTTP]]\n* [[ODBC]]\n* [[Remote evaluation]]\n* [[External Data Representation]]\n* [[Resource-oriented architecture]]\n* [[Distributed object middleware]]\n* [[Fragmented object]]\n* [[gRPC]]\n\n==References==\n{{reflist}}\n\n==External links==\n*RFC 1057 - Specifies version 1 of ONC RPC\n*RFC 5531 - Specifies version 2 of ONC RPC\n*[http://www.cs.cf.ac.uk/Dave/C/node33.html Remote Procedure Calls (RPC)] &mdash; A tutorial on ONC RPC by Dr Dave Marshall of Cardiff University\n*[https://web.archive.org/web/20030404113118/http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&db=bks&srch=&fname=/SGI_Developer/IRIX_NetPG/sgi_html/ch04.html Introduction to RPC Programming] &mdash; A developer's introduction to RPC and XDR, from SGI IRIX documentation.\n\n[[Category:Inter-process communication]]\n[[Category:Middleware]]\n[[Category:Remote procedure call| ]]\n[[Category:Distributed computing]]\n", "name_user": "Gnash", "label": "safe", "comment": "", "url_page": "//en.wikipedia.org/wiki/Remote_procedure_call"}
